"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client";
exports.ids = ["vendor-chunks/openid-client"];
exports.modules = {

/***/ "(rsc)/./node_modules/openid-client/build/index.js":
/*!***************************************************!*\
  !*** ./node_modules/openid-client/build/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthorizationResponseError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.AuthorizationResponseError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ClientSecretBasic: () => (/* binding */ ClientSecretBasic),\n/* harmony export */   ClientSecretJwt: () => (/* binding */ ClientSecretJwt),\n/* harmony export */   ClientSecretPost: () => (/* binding */ ClientSecretPost),\n/* harmony export */   Configuration: () => (/* binding */ Configuration),\n/* harmony export */   None: () => (/* binding */ None),\n/* harmony export */   PrivateKeyJwt: () => (/* binding */ PrivateKeyJwt),\n/* harmony export */   ResponseBodyError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError),\n/* harmony export */   TlsClientAuth: () => (/* binding */ TlsClientAuth),\n/* harmony export */   WWWAuthenticateChallengeError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.WWWAuthenticateChallengeError),\n/* harmony export */   allowInsecureRequests: () => (/* binding */ allowInsecureRequests),\n/* harmony export */   authorizationCodeGrant: () => (/* binding */ authorizationCodeGrant),\n/* harmony export */   buildAuthorizationUrl: () => (/* binding */ buildAuthorizationUrl),\n/* harmony export */   buildAuthorizationUrlWithJAR: () => (/* binding */ buildAuthorizationUrlWithJAR),\n/* harmony export */   buildAuthorizationUrlWithPAR: () => (/* binding */ buildAuthorizationUrlWithPAR),\n/* harmony export */   buildEndSessionUrl: () => (/* binding */ buildEndSessionUrl),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrant: () => (/* binding */ clientCredentialsGrant),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   customFetch: () => (/* binding */ customFetch),\n/* harmony export */   discovery: () => (/* binding */ discovery),\n/* harmony export */   dynamicClientRegistration: () => (/* binding */ dynamicClientRegistration),\n/* harmony export */   enableDecryptingResponses: () => (/* binding */ enableDecryptingResponses),\n/* harmony export */   enableDetachedSignatureResponseChecks: () => (/* binding */ enableDetachedSignatureResponseChecks),\n/* harmony export */   enableNonRepudiationChecks: () => (/* binding */ enableNonRepudiationChecks),\n/* harmony export */   fetchProtectedResource: () => (/* binding */ fetchProtectedResource),\n/* harmony export */   fetchUserInfo: () => (/* binding */ fetchUserInfo),\n/* harmony export */   genericGrantRequest: () => (/* binding */ genericGrantRequest),\n/* harmony export */   getDPoPHandle: () => (/* binding */ getDPoPHandle),\n/* harmony export */   getJwksCache: () => (/* binding */ getJwksCache),\n/* harmony export */   implicitAuthentication: () => (/* binding */ implicitAuthentication),\n/* harmony export */   initiateBackchannelAuthentication: () => (/* binding */ initiateBackchannelAuthentication),\n/* harmony export */   initiateDeviceAuthorization: () => (/* binding */ initiateDeviceAuthorization),\n/* harmony export */   modifyAssertion: () => (/* binding */ modifyAssertion),\n/* harmony export */   pollBackchannelAuthenticationGrant: () => (/* binding */ pollBackchannelAuthenticationGrant),\n/* harmony export */   pollDeviceAuthorizationGrant: () => (/* binding */ pollDeviceAuthorizationGrant),\n/* harmony export */   randomDPoPKeyPair: () => (/* binding */ randomDPoPKeyPair),\n/* harmony export */   randomNonce: () => (/* binding */ randomNonce),\n/* harmony export */   randomPKCECodeVerifier: () => (/* binding */ randomPKCECodeVerifier),\n/* harmony export */   randomState: () => (/* binding */ randomState),\n/* harmony export */   refreshTokenGrant: () => (/* binding */ refreshTokenGrant),\n/* harmony export */   setJwksCache: () => (/* binding */ setJwksCache),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   tokenIntrospection: () => (/* binding */ tokenIntrospection),\n/* harmony export */   tokenRevocation: () => (/* binding */ tokenRevocation),\n/* harmony export */   useCodeIdTokenResponseType: () => (/* binding */ useCodeIdTokenResponseType),\n/* harmony export */   useIdTokenResponseType: () => (/* binding */ useIdTokenResponseType),\n/* harmony export */   useJwtResponseMode: () => (/* binding */ useJwtResponseMode)\n/* harmony export */ });\n/* harmony import */ var oauth4webapi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! oauth4webapi */ \"(rsc)/./node_modules/oauth4webapi/build/index.js\");\n/* harmony import */ var jose_jwe_compact_decrypt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jose/jwe/compact/decrypt */ \"(rsc)/./node_modules/jose/dist/webapi/jwe/compact/decrypt.js\");\n/* harmony import */ var jose_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jose/errors */ \"(rsc)/./node_modules/jose/dist/webapi/util/errors.js\");\n\n\n\nlet headers;\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'openid-client';\n    const VERSION = 'v6.8.1';\n    USER_AGENT = `${NAME}/${VERSION}`;\n    headers = { 'user-agent': USER_AGENT };\n}\nconst int = (config) => {\n    return props.get(config);\n};\nlet props;\n\nlet tbi;\nfunction ClientSecretPost(clientSecret) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretPost(clientSecret);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretPost(client.client_secret);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction assertString(input, it) {\n    if (typeof input !== 'string') {\n        throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE);\n    }\n    if (input.length === 0) {\n        throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction ClientSecretBasic(clientSecret) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretBasic(clientSecret);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretBasic(client.client_secret);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction ClientSecretJwt(clientSecret, options) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretJwt(clientSecret, options);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretJwt(client.client_secret, options);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction None() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.None();\n}\nfunction PrivateKeyJwt(clientPrivateKey, options) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyJwt(clientPrivateKey, options);\n}\nfunction TlsClientAuth() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.TlsClientAuth();\n}\nconst skipStateCheck = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.skipStateCheck;\nconst skipSubjectCheck = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.skipSubjectCheck;\nconst customFetch = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch;\nconst modifyAssertion = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.modifyAssertion;\nconst clockSkew = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew;\nconst clockTolerance = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance;\nconst ERR_INVALID_ARG_VALUE = 'ERR_INVALID_ARG_VALUE';\nconst ERR_INVALID_ARG_TYPE = 'ERR_INVALID_ARG_TYPE';\nfunction CodedTypeError(message, code, cause) {\n    const err = new TypeError(message, { cause });\n    Object.assign(err, { code });\n    return err;\n}\nfunction calculatePKCECodeChallenge(codeVerifier) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.calculatePKCECodeChallenge(codeVerifier);\n}\nfunction randomPKCECodeVerifier() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomCodeVerifier();\n}\nfunction randomNonce() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomNonce();\n}\nfunction randomState() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomState();\n}\nclass ClientError extends Error {\n    code;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = options?.code;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst decoder = new TextDecoder();\nfunction e(msg, cause, code) {\n    return new ClientError(msg, { cause, code });\n}\nfunction errorHandler(err) {\n    if (err instanceof TypeError ||\n        err instanceof ClientError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.AuthorizationResponseError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.WWWAuthenticateChallengeError) {\n        throw err;\n    }\n    if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.OperationProcessingError) {\n        switch (err.code) {\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.HTTP_REQUEST_FORBIDDEN:\n                throw e('only requests to HTTPS are allowed', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.REQUEST_PROTOCOL_FORBIDDEN:\n                throw e('only requests to HTTP or HTTPS are allowed', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.RESPONSE_IS_NOT_CONFORM:\n                throw e('unexpected HTTP response status code', err.cause, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.RESPONSE_IS_NOT_JSON:\n                throw e('unexpected response content-type', err.cause, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.PARSE_ERROR:\n                throw e('parsing error occured', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.INVALID_RESPONSE:\n                throw e('invalid response encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JWT_CLAIM_COMPARISON:\n                throw e('unexpected JWT claim value encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JSON_ATTRIBUTE_COMPARISON:\n                throw e('unexpected JSON attribute value encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JWT_TIMESTAMP_CHECK:\n                throw e('JWT timestamp claim value failed validation', err, err.code);\n            default:\n                throw e(err.message, err, err.code);\n        }\n    }\n    if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UnsupportedOperationError) {\n        throw e('unsupported operation', err, err.code);\n    }\n    if (err instanceof DOMException) {\n        switch (err.name) {\n            case 'OperationError':\n                throw e('runtime operation error', err, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n            case 'NotSupportedError':\n                throw e('runtime unsupported operation', err, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n            case 'TimeoutError':\n                throw e('operation timed out', err, 'OAUTH_TIMEOUT');\n            case 'AbortError':\n                throw e('operation aborted', err, 'OAUTH_ABORT');\n        }\n    }\n    throw new ClientError('something went wrong', { cause: err });\n}\nfunction randomDPoPKeyPair(alg, options) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateKeyPair(alg ?? 'ES256', {\n        extractable: options?.extractable,\n    })\n        .catch(errorHandler);\n}\nfunction handleEntraId(server, as, options) {\n    if (server.origin === 'https://login.microsoftonline.com' &&\n        (!options?.algorithm || options.algorithm === 'oidc')) {\n        as[kEntraId] = true;\n        return true;\n    }\n    return false;\n}\nfunction handleB2Clogin(server, options) {\n    if (server.hostname.endsWith('.b2clogin.com') &&\n        (!options?.algorithm || options.algorithm === 'oidc')) {\n        return true;\n    }\n    return false;\n}\nasync function dynamicClientRegistration(server, metadata, clientAuthentication, options) {\n    let as;\n    if (options?.flag === retry) {\n        as = options.as;\n    }\n    else {\n        as = await performDiscovery(server, options);\n    }\n    const clockSkew = metadata[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] ?? 0;\n    const clockTolerance = metadata[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] ?? 30;\n    metadata = structuredClone(metadata);\n    const timeout = options?.timeout ?? 30;\n    const signal = AbortSignal.timeout(timeout * 1000);\n    let registered;\n    try {\n        registered = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.dynamicClientRegistrationRequest(as, metadata, {\n            initialAccessToken: options?.initialAccessToken,\n            DPoP: options?.DPoP,\n            headers: new Headers(headers),\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: options?.[customFetch],\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: options?.execute?.includes(allowInsecureRequests),\n            signal,\n        })\n            .then(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDynamicClientRegistrationResponse);\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return dynamicClientRegistration(server, metadata, clientAuthentication, {\n                ...options,\n                flag: retry,\n                as,\n            });\n        }\n        errorHandler(err);\n    }\n    registered[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] = clockSkew;\n    registered[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] = clockTolerance;\n    const instance = new Configuration(as, registered.client_id, registered, clientAuthentication);\n    let internals = int(instance);\n    if (options?.[customFetch]) {\n        internals.fetch = options[customFetch];\n    }\n    if (options?.timeout) {\n        internals.timeout = options.timeout;\n    }\n    if (options?.execute) {\n        for (const extension of options.execute) {\n            extension(instance);\n        }\n    }\n    return instance;\n}\nasync function discovery(server, clientId, metadata, clientAuthentication, options) {\n    const as = await performDiscovery(server, options);\n    const instance = new Configuration(as, clientId, metadata, clientAuthentication);\n    let internals = int(instance);\n    if (options?.[customFetch]) {\n        internals.fetch = options[customFetch];\n    }\n    if (options?.timeout) {\n        internals.timeout = options.timeout;\n    }\n    if (options?.execute) {\n        for (const extension of options.execute) {\n            extension(instance);\n        }\n    }\n    return instance;\n}\nasync function performDiscovery(server, options) {\n    if (!(server instanceof URL)) {\n        throw CodedTypeError('\"server\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    const resolve = !server.href.includes('/.well-known/');\n    const timeout = options?.timeout ?? 30;\n    const signal = AbortSignal.timeout(timeout * 1000);\n    const as = await (resolve\n        ? oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.discoveryRequest(server, {\n            algorithm: options?.algorithm,\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: options?.[customFetch],\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: options?.execute?.includes(allowInsecureRequests),\n            signal,\n            headers: new Headers(headers),\n        })\n        : (options?.[customFetch] || fetch)((() => {\n            oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.checkProtocol(server, options?.execute?.includes(allowInsecureRequests) ? false : true);\n            return server.href;\n        })(), {\n            headers: Object.fromEntries(new Headers({ accept: 'application/json', ...headers }).entries()),\n            body: undefined,\n            method: 'GET',\n            redirect: 'manual',\n            signal,\n        }))\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDiscoveryResponse(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__._nodiscoverycheck, response))\n        .catch(errorHandler);\n    if (resolve && new URL(as.issuer).href !== server.href) {\n        handleEntraId(server, as, options) ||\n            handleB2Clogin(server, options) ||\n            (() => {\n                throw new ClientError('discovered metadata issuer does not match the expected issuer', {\n                    code: oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JSON_ATTRIBUTE_COMPARISON,\n                    cause: {\n                        expected: server.href,\n                        body: as,\n                        attribute: 'issuer',\n                    },\n                });\n            })();\n    }\n    return as;\n}\nfunction isRsaOaep(input) {\n    return input.name === 'RSA-OAEP';\n}\nfunction isEcdh(input) {\n    return input.name === 'ECDH';\n}\nconst ecdhEs = 'ECDH-ES';\nconst ecdhEsA128Kw = 'ECDH-ES+A128KW';\nconst ecdhEsA192Kw = 'ECDH-ES+A192KW';\nconst ecdhEsA256Kw = 'ECDH-ES+A256KW';\nfunction checkEcdhAlg(algs, alg, pk) {\n    switch (alg) {\n        case undefined:\n            algs.add(ecdhEs);\n            algs.add(ecdhEsA128Kw);\n            algs.add(ecdhEsA192Kw);\n            algs.add(ecdhEsA256Kw);\n            break;\n        case ecdhEs:\n        case ecdhEsA128Kw:\n        case ecdhEsA192Kw:\n        case ecdhEsA256Kw:\n            algs.add(alg);\n            break;\n        default:\n            throw CodedTypeError('invalid key alg', ERR_INVALID_ARG_VALUE, { pk });\n    }\n}\nfunction enableDecryptingResponses(config, contentEncryptionAlgorithms = [\n    'A128GCM',\n    'A192GCM',\n    'A256GCM',\n    'A128CBC-HS256',\n    'A192CBC-HS384',\n    'A256CBC-HS512',\n], ...keys) {\n    if (int(config).decrypt !== undefined) {\n        throw new TypeError('enableDecryptingResponses can only be called on a given Configuration instance once');\n    }\n    if (keys.length === 0) {\n        throw CodedTypeError('no keys were provided', ERR_INVALID_ARG_VALUE);\n    }\n    const algs = new Set();\n    const normalized = [];\n    for (const pk of keys) {\n        let key;\n        if ('key' in pk) {\n            key = { key: pk.key };\n            if (typeof pk.alg === 'string')\n                key.alg = pk.alg;\n            if (typeof pk.kid === 'string')\n                key.kid = pk.kid;\n        }\n        else {\n            key = { key: pk };\n        }\n        if (key.key.type !== 'private') {\n            throw CodedTypeError('only private keys must be provided', ERR_INVALID_ARG_VALUE);\n        }\n        if (isRsaOaep(key.key.algorithm)) {\n            switch (key.key.algorithm.hash.name) {\n                case 'SHA-1':\n                case 'SHA-256':\n                case 'SHA-384':\n                case 'SHA-512': {\n                    let alg = 'RSA-OAEP';\n                    let sha;\n                    if ((sha = parseInt(key.key.algorithm.hash.name.slice(-3), 10))) {\n                        alg = `${alg}-${sha}`;\n                    }\n                    key.alg ||= alg;\n                    if (alg !== key.alg)\n                        throw CodedTypeError('invalid key alg', ERR_INVALID_ARG_VALUE, {\n                            pk,\n                        });\n                    algs.add(key.alg);\n                    break;\n                }\n                default:\n                    throw CodedTypeError('only SHA-512, SHA-384, SHA-256, and SHA-1 RSA-OAEP keys are supported', ERR_INVALID_ARG_VALUE);\n            }\n        }\n        else if (isEcdh(key.key.algorithm)) {\n            if (key.key.algorithm.namedCurve !== 'P-256') {\n                throw CodedTypeError('Only P-256 ECDH keys are supported', ERR_INVALID_ARG_VALUE);\n            }\n            checkEcdhAlg(algs, key.alg, pk);\n        }\n        else if (key.key.algorithm.name === 'X25519') {\n            checkEcdhAlg(algs, key.alg, pk);\n        }\n        else {\n            throw CodedTypeError('only RSA-OAEP, ECDH, or X25519 keys are supported', ERR_INVALID_ARG_VALUE);\n        }\n        normalized.push(key);\n    }\n    int(config).decrypt = async (jwe) => decrypt(normalized, jwe, contentEncryptionAlgorithms, [...algs]).catch(errorHandler);\n}\nfunction checkCryptoKey(key, alg, epk) {\n    if (alg.startsWith('RSA-OAEP')) {\n        return true;\n    }\n    if (alg.startsWith('ECDH-ES')) {\n        if (key.algorithm.name !== 'ECDH' && key.algorithm.name !== 'X25519') {\n            return false;\n        }\n        if (key.algorithm.name === 'ECDH') {\n            return epk?.crv === key.algorithm.namedCurve;\n        }\n        if (key.algorithm.name === 'X25519') {\n            return epk?.crv === 'X25519';\n        }\n    }\n    return false;\n}\nfunction selectCryptoKeyForDecryption(keys, alg, kid, epk) {\n    const { 0: key, length } = keys.filter((key) => {\n        if (kid !== key.kid) {\n            return false;\n        }\n        if (key.alg && alg !== key.alg) {\n            return false;\n        }\n        return checkCryptoKey(key.key, alg, epk);\n    });\n    if (!key) {\n        throw e('no applicable decryption key selected', undefined, 'OAUTH_DECRYPTION_FAILED');\n    }\n    if (length !== 1) {\n        throw e('multiple applicable decryption keys selected', undefined, 'OAUTH_DECRYPTION_FAILED');\n    }\n    return key.key;\n}\nasync function decrypt(keys, jwe, contentEncryptionAlgorithms, keyManagementAlgorithms) {\n    return decoder.decode((await (0,jose_jwe_compact_decrypt__WEBPACK_IMPORTED_MODULE_1__.compactDecrypt)(jwe, (header) => {\n        const { kid, alg, epk } = header;\n        return selectCryptoKeyForDecryption(keys, alg, kid, epk);\n    }, { keyManagementAlgorithms, contentEncryptionAlgorithms }).catch((err) => {\n        if (err instanceof jose_errors__WEBPACK_IMPORTED_MODULE_2__.JOSEError) {\n            throw e('decryption failed', err, 'OAUTH_DECRYPTION_FAILED');\n        }\n        errorHandler(err);\n    })).plaintext);\n}\nfunction getServerHelpers(metadata) {\n    return {\n        supportsPKCE: {\n            __proto__: null,\n            value(method = 'S256') {\n                return (metadata.code_challenge_methods_supported?.includes(method) === true);\n            },\n        },\n    };\n}\nfunction addServerHelpers(metadata) {\n    Object.defineProperties(metadata, getServerHelpers(metadata));\n}\nconst kEntraId = Symbol();\nclass Configuration {\n    constructor(server, clientId, metadata, clientAuthentication) {\n        if (typeof clientId !== 'string' || !clientId.length) {\n            throw CodedTypeError('\"clientId\" must be a non-empty string', ERR_INVALID_ARG_TYPE);\n        }\n        if (typeof metadata === 'string') {\n            metadata = { client_secret: metadata };\n        }\n        if (metadata?.client_id !== undefined && clientId !== metadata.client_id) {\n            throw CodedTypeError('\"clientId\" and \"metadata.client_id\" must be the same', ERR_INVALID_ARG_VALUE);\n        }\n        const client = {\n            ...structuredClone(metadata),\n            client_id: clientId,\n        };\n        client[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] = metadata?.[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] ?? 0;\n        client[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] = metadata?.[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] ?? 30;\n        let auth;\n        if (clientAuthentication) {\n            auth = clientAuthentication;\n        }\n        else {\n            if (typeof client.client_secret === 'string' &&\n                client.client_secret.length) {\n                auth = ClientSecretPost(client.client_secret);\n            }\n            else {\n                auth = None();\n            }\n        }\n        let c = Object.freeze(client);\n        const clone = structuredClone(server);\n        if (kEntraId in server) {\n            clone[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__._expectedIssuer] = ({ claims: { tid } }) => server.issuer.replace('{tenantid}', tid);\n        }\n        let as = Object.freeze(clone);\n        props ||= new WeakMap();\n        props.set(this, {\n            __proto__: null,\n            as,\n            c,\n            auth,\n            tlsOnly: true,\n            jwksCache: {},\n        });\n    }\n    serverMetadata() {\n        const metadata = structuredClone(int(this).as);\n        addServerHelpers(metadata);\n        return metadata;\n    }\n    clientMetadata() {\n        const metadata = structuredClone(int(this).c);\n        return metadata;\n    }\n    get timeout() {\n        return int(this).timeout;\n    }\n    set timeout(value) {\n        int(this).timeout = value;\n    }\n    get [customFetch]() {\n        return int(this).fetch;\n    }\n    set [customFetch](value) {\n        int(this).fetch = value;\n    }\n}\nObject.freeze(Configuration.prototype);\nfunction getHelpers(response) {\n    let exp = undefined;\n    if (response.expires_in !== undefined) {\n        const now = new Date();\n        now.setSeconds(now.getSeconds() + response.expires_in);\n        exp = now.getTime();\n    }\n    return {\n        expiresIn: {\n            __proto__: null,\n            value() {\n                if (exp) {\n                    const now = Date.now();\n                    if (exp > now) {\n                        return Math.floor((exp - now) / 1000);\n                    }\n                    return 0;\n                }\n                return undefined;\n            },\n        },\n        claims: {\n            __proto__: null,\n            value() {\n                try {\n                    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getValidatedIdTokenClaims(this);\n                }\n                catch {\n                    return undefined;\n                }\n            },\n        },\n    };\n}\nfunction addHelpers(response) {\n    Object.defineProperties(response, getHelpers(response));\n}\nfunction getDPoPHandle(config, keyPair, options) {\n    checkConfig(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.DPoP(int(config).c, keyPair, options);\n}\nasync function handleRetryAfter(response, currentInterval, signal, throwIfInvalid = false) {\n    const retryAfter = response.headers.get('retry-after')?.trim();\n    if (retryAfter === undefined)\n        return;\n    let delaySeconds;\n    if (/^\\d+$/.test(retryAfter)) {\n        delaySeconds = parseInt(retryAfter, 10);\n    }\n    else {\n        const retryDate = new Date(retryAfter);\n        if (Number.isFinite(retryDate.getTime())) {\n            const now = new Date();\n            const delayMs = retryDate.getTime() - now.getTime();\n            if (delayMs > 0) {\n                delaySeconds = Math.ceil(delayMs / 1000);\n            }\n        }\n    }\n    if (throwIfInvalid && !Number.isFinite(delaySeconds)) {\n        throw new oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.OperationProcessingError('invalid Retry-After header value', { cause: response });\n    }\n    if (delaySeconds > currentInterval) {\n        await wait(delaySeconds - currentInterval, signal);\n    }\n}\nfunction wait(duration, signal) {\n    return new Promise((resolve, reject) => {\n        const waitStep = (remaining) => {\n            try {\n                signal.throwIfAborted();\n            }\n            catch (err) {\n                reject(err);\n                return;\n            }\n            if (remaining <= 0) {\n                resolve();\n                return;\n            }\n            const currentWait = Math.min(remaining, 5);\n            setTimeout(() => waitStep(remaining - currentWait), currentWait * 1000);\n        };\n        waitStep(duration);\n    });\n}\nasync function pollDeviceAuthorizationGrant(config, deviceAuthorizationResponse, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    let interval = deviceAuthorizationResponse.interval ?? 5;\n    const pollingSignal = options?.signal ??\n        AbortSignal.timeout(deviceAuthorizationResponse.expires_in * 1000);\n    try {\n        await wait(interval, pollingSignal);\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const retryPoll = (updatedInterval, flag) => pollDeviceAuthorizationGrant(config, {\n        ...deviceAuthorizationResponse,\n        interval: updatedInterval,\n    }, parameters, {\n        ...options,\n        signal: pollingSignal,\n        flag,\n    });\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.deviceCodeGrantRequest(as, c, auth, deviceAuthorizationResponse.device_code, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: pollingSignal.aborted ? pollingSignal : signal(timeout),\n    })\n        .catch(errorHandler);\n    if (response.status === 503 && response.headers.has('retry-after')) {\n        await handleRetryAfter(response, interval, pollingSignal, true);\n        await response.body?.cancel();\n        return retryPoll(interval);\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDeviceCodeResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return retryPoll(interval, retry);\n        }\n        if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError) {\n            switch (err.error) {\n                case 'slow_down':\n                    interval += 5;\n                case 'authorization_pending':\n                    await handleRetryAfter(err.response, interval, pollingSignal);\n                    return retryPoll(interval);\n            }\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function initiateDeviceAuthorization(config, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.deviceAuthorizationRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDeviceAuthorizationResponse(as, c, response))\n        .catch(errorHandler);\n}\nasync function initiateBackchannelAuthentication(config, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.backchannelAuthenticationRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processBackchannelAuthenticationResponse(as, c, response))\n        .catch(errorHandler);\n}\nasync function pollBackchannelAuthenticationGrant(config, backchannelAuthenticationResponse, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    let interval = backchannelAuthenticationResponse.interval ?? 5;\n    const pollingSignal = options?.signal ??\n        AbortSignal.timeout(backchannelAuthenticationResponse.expires_in * 1000);\n    try {\n        await wait(interval, pollingSignal);\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const retryPoll = (updatedInterval, flag) => pollBackchannelAuthenticationGrant(config, {\n        ...backchannelAuthenticationResponse,\n        interval: updatedInterval,\n    }, parameters, {\n        ...options,\n        signal: pollingSignal,\n        flag,\n    });\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.backchannelAuthenticationGrantRequest(as, c, auth, backchannelAuthenticationResponse.auth_req_id, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: pollingSignal.aborted ? pollingSignal : signal(timeout),\n    })\n        .catch(errorHandler);\n    if (response.status === 503 && response.headers.has('retry-after')) {\n        await handleRetryAfter(response, interval, pollingSignal, true);\n        await response.body?.cancel();\n        return retryPoll(interval);\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processBackchannelAuthenticationGrantResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return retryPoll(interval, retry);\n        }\n        if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError) {\n            switch (err.error) {\n                case 'slow_down':\n                    interval += 5;\n                case 'authorization_pending':\n                    await handleRetryAfter(err.response, interval, pollingSignal);\n                    return retryPoll(interval);\n            }\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nfunction allowInsecureRequests(config) {\n    int(config).tlsOnly = false;\n}\nfunction setJwksCache(config, jwksCache) {\n    int(config).jwksCache = structuredClone(jwksCache);\n}\nfunction getJwksCache(config) {\n    const cache = int(config).jwksCache;\n    if (cache.uat) {\n        return cache;\n    }\n    return undefined;\n}\nfunction enableNonRepudiationChecks(config) {\n    checkConfig(config);\n    int(config).nonRepudiation = (response) => {\n        const { as, fetch, tlsOnly, timeout, jwksCache } = int(config);\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateApplicationLevelSignature(as, response, {\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n            headers: new Headers(headers),\n            signal: signal(timeout),\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n        })\n            .catch(errorHandler);\n    };\n}\nfunction useJwtResponseMode(config) {\n    checkConfig(config);\n    const { hybrid, implicit } = int(config);\n    if (hybrid || implicit) {\n        throw e('JARM cannot be combined with a hybrid or implicit response types', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).jarm = (authorizationResponse, expectedState) => validateJARMResponse(config, authorizationResponse, expectedState);\n}\nfunction enableDetachedSignatureResponseChecks(config) {\n    if (!int(config).hybrid) {\n        throw e('\"code id_token\" response type must be configured to be used first', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).hybrid = (authorizationResponse, expectedNonce, expectedState, maxAge) => validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, true);\n}\nasync function implicitAuthentication(config, currentUrl, expectedNonce, checks) {\n    checkConfig(config);\n    if (!(currentUrl instanceof URL) &&\n        !webInstanceOf(currentUrl, 'Request')) {\n        throw CodedTypeError('\"currentUrl\" must be an instance of URL, or Request', ERR_INVALID_ARG_TYPE);\n    }\n    if (typeof expectedNonce !== 'string') {\n        throw CodedTypeError('\"expectedNonce\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    const { as, c, fetch, tlsOnly, timeout, decrypt, implicit, jwksCache } = int(config);\n    if (!implicit) {\n        throw new TypeError('implicitAuthentication() cannot be used by clients using flows other than response_type=id_token');\n    }\n    let params;\n    if (!(currentUrl instanceof URL)) {\n        const request = currentUrl;\n        switch (request.method) {\n            case 'GET':\n                params = new URLSearchParams(new URL(request.url).hash.slice(1));\n                break;\n            case 'POST':\n                params = new URLSearchParams(await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.formPostResponse(request));\n                break;\n            default:\n                throw CodedTypeError('unexpected Request HTTP method', ERR_INVALID_ARG_VALUE);\n        }\n    }\n    else {\n        params = new URLSearchParams(currentUrl.hash.slice(1));\n    }\n    try {\n        {\n            const decoy = new URLSearchParams(params);\n            decoy.delete('id_token');\n            oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateAuthResponse({\n                ...as,\n                authorization_response_iss_parameter_supported: undefined,\n            }, c, decoy, checks?.expectedState);\n        }\n        {\n            const decoy = new Response(JSON.stringify({\n                access_token: 'decoy',\n                token_type: 'bearer',\n                id_token: params.get('id_token'),\n            }), {\n                headers: new Headers({ 'content-type': 'application/json' }),\n            });\n            const ref = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processAuthorizationCodeResponse(as, c, decoy, {\n                expectedNonce,\n                maxAge: checks?.maxAge,\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n            });\n            await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateApplicationLevelSignature(as, decoy, {\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n                headers: new Headers(headers),\n                signal: signal(timeout),\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n            });\n            return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getValidatedIdTokenClaims(ref);\n        }\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n}\nfunction useCodeIdTokenResponseType(config) {\n    checkConfig(config);\n    const { jarm, implicit } = int(config);\n    if (jarm || implicit) {\n        throw e('\"code id_token\" response type cannot be combined with JARM or implicit response type', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).hybrid = (authorizationResponse, expectedNonce, expectedState, maxAge) => validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, false);\n}\nfunction useIdTokenResponseType(config) {\n    checkConfig(config);\n    const { jarm, hybrid } = int(config);\n    if (jarm || hybrid) {\n        throw e('\"id_token\" response type cannot be combined with JARM or hybrid response type', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).implicit = true;\n}\nfunction stripParams(url) {\n    url = new URL(url);\n    url.search = '';\n    url.hash = '';\n    return url.href;\n}\nfunction webInstanceOf(input, toStringTag) {\n    try {\n        return Object.getPrototypeOf(input)[Symbol.toStringTag] === toStringTag;\n    }\n    catch {\n        return false;\n    }\n}\nasync function authorizationCodeGrant(config, currentUrl, checks, tokenEndpointParameters, options) {\n    checkConfig(config);\n    if (options?.flag !== retry &&\n        !(currentUrl instanceof URL) &&\n        !webInstanceOf(currentUrl, 'Request')) {\n        throw CodedTypeError('\"currentUrl\" must be an instance of URL, or Request', ERR_INVALID_ARG_TYPE);\n    }\n    let authResponse;\n    let redirectUri;\n    const { as, c, auth, fetch, tlsOnly, jarm, hybrid, nonRepudiation, timeout, decrypt, implicit } = int(config);\n    if (options?.flag === retry) {\n        authResponse = options.authResponse;\n        redirectUri = options.redirectUri;\n    }\n    else {\n        if (!(currentUrl instanceof URL)) {\n            const request = currentUrl;\n            currentUrl = new URL(currentUrl.url);\n            switch (request.method) {\n                case 'GET':\n                    break;\n                case 'POST':\n                    const params = new URLSearchParams(await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.formPostResponse(request));\n                    if (hybrid) {\n                        currentUrl.hash = params.toString();\n                    }\n                    else {\n                        for (const [k, v] of params.entries()) {\n                            currentUrl.searchParams.append(k, v);\n                        }\n                    }\n                    break;\n                default:\n                    throw CodedTypeError('unexpected Request HTTP method', ERR_INVALID_ARG_VALUE);\n            }\n        }\n        redirectUri = stripParams(currentUrl);\n        switch (true) {\n            case !!jarm:\n                authResponse = await jarm(currentUrl, checks?.expectedState);\n                break;\n            case !!hybrid:\n                authResponse = await hybrid(currentUrl, checks?.expectedNonce, checks?.expectedState, checks?.maxAge);\n                break;\n            case !!implicit:\n                throw new TypeError('authorizationCodeGrant() cannot be used by response_type=id_token clients');\n            default:\n                try {\n                    authResponse = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateAuthResponse(as, c, currentUrl.searchParams, checks?.expectedState);\n                }\n                catch (err) {\n                    errorHandler(err);\n                }\n        }\n    }\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.authorizationCodeGrantRequest(as, c, auth, authResponse, redirectUri, checks?.pkceCodeVerifier || oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.nopkce, {\n        additionalParameters: tokenEndpointParameters,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    if (typeof checks?.expectedNonce === 'string' ||\n        typeof checks?.maxAge === 'number') {\n        checks.idTokenExpected = true;\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processAuthorizationCodeResponse(as, c, response, {\n        expectedNonce: checks?.expectedNonce,\n        maxAge: checks?.maxAge,\n        requireIdToken: checks?.idTokenExpected,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return authorizationCodeGrant(config, undefined, checks, tokenEndpointParameters, {\n                ...options,\n                flag: retry,\n                authResponse: authResponse,\n                redirectUri: redirectUri,\n            });\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function validateJARMResponse(config, authorizationResponse, expectedState) {\n    const { as, c, fetch, tlsOnly, timeout, decrypt, jwksCache } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateJwtAuthResponse(as, c, authorizationResponse, expectedState, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n    })\n        .catch(errorHandler);\n}\nasync function validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, fapi) {\n    if (typeof expectedNonce !== 'string') {\n        throw CodedTypeError('\"expectedNonce\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    if (expectedState !== undefined && typeof expectedState !== 'string') {\n        throw CodedTypeError('\"expectedState\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    const { as, c, fetch, tlsOnly, timeout, decrypt, jwksCache } = int(config);\n    return (fapi\n        ? oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateDetachedSignatureResponse\n        : oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateCodeIdTokenResponse)(as, c, authorizationResponse, expectedNonce, expectedState, maxAge, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n    }).catch(errorHandler);\n}\nasync function refreshTokenGrant(config, refreshToken, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.refreshTokenGrantRequest(as, c, auth, refreshToken, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processRefreshTokenResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return refreshTokenGrant(config, refreshToken, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function clientCredentialsGrant(config, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clientCredentialsGrantRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processClientCredentialsResponse(as, c, response);\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return clientCredentialsGrant(config, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    addHelpers(result);\n    return result;\n}\nfunction buildAuthorizationUrl(config, parameters) {\n    checkConfig(config);\n    const { as, c, tlsOnly, hybrid, jarm, implicit } = int(config);\n    const authorizationEndpoint = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.resolveEndpoint(as, 'authorization_endpoint', false, tlsOnly);\n    parameters = new URLSearchParams(parameters);\n    if (!parameters.has('client_id')) {\n        parameters.set('client_id', c.client_id);\n    }\n    if (!parameters.has('request_uri') && !parameters.has('request')) {\n        if (!parameters.has('response_type')) {\n            parameters.set('response_type', hybrid ? 'code id_token' : implicit ? 'id_token' : 'code');\n        }\n        if (implicit && !parameters.has('nonce')) {\n            throw CodedTypeError('response_type=id_token clients must provide a nonce parameter in their authorization request parameters', ERR_INVALID_ARG_VALUE);\n        }\n        if (jarm) {\n            parameters.set('response_mode', 'jwt');\n        }\n    }\n    for (const [k, v] of parameters.entries()) {\n        authorizationEndpoint.searchParams.append(k, v);\n    }\n    return authorizationEndpoint;\n}\nasync function buildAuthorizationUrlWithJAR(config, parameters, signingKey, options) {\n    checkConfig(config);\n    const authorizationEndpoint = buildAuthorizationUrl(config, parameters);\n    parameters = authorizationEndpoint.searchParams;\n    if (!signingKey) {\n        throw CodedTypeError('\"signingKey\" must be provided', ERR_INVALID_ARG_VALUE);\n    }\n    const { as, c } = int(config);\n    const request = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.issueRequestObject(as, c, parameters, signingKey, options)\n        .catch(errorHandler);\n    return buildAuthorizationUrl(config, { request });\n}\nasync function buildAuthorizationUrlWithPAR(config, parameters, options) {\n    checkConfig(config);\n    const authorizationEndpoint = buildAuthorizationUrl(config, parameters);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.pushedAuthorizationRequest(as, c, auth, authorizationEndpoint.searchParams, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processPushedAuthorizationResponse(as, c, response);\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return buildAuthorizationUrlWithPAR(config, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    return buildAuthorizationUrl(config, { request_uri: result.request_uri });\n}\nfunction buildEndSessionUrl(config, parameters) {\n    checkConfig(config);\n    const { as, c, tlsOnly } = int(config);\n    const endSessionEndpoint = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.resolveEndpoint(as, 'end_session_endpoint', false, tlsOnly);\n    parameters = new URLSearchParams(parameters);\n    if (!parameters.has('client_id')) {\n        parameters.set('client_id', c.client_id);\n    }\n    for (const [k, v] of parameters.entries()) {\n        endSessionEndpoint.searchParams.append(k, v);\n    }\n    return endSessionEndpoint;\n}\nfunction checkConfig(input) {\n    if (!(input instanceof Configuration)) {\n        throw CodedTypeError('\"config\" must be an instance of Configuration', ERR_INVALID_ARG_TYPE);\n    }\n    if (Object.getPrototypeOf(input) !== Configuration.prototype) {\n        throw CodedTypeError('subclassing Configuration is not allowed', ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction signal(timeout) {\n    return timeout ? AbortSignal.timeout(timeout * 1000) : undefined;\n}\nasync function fetchUserInfo(config, accessToken, expectedSubject, options) {\n    checkConfig(config);\n    const { as, c, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.userInfoRequest(as, c, accessToken, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    let exec = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processUserInfoResponse(as, c, expectedSubject, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await exec;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return fetchUserInfo(config, accessToken, expectedSubject, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getContentType(response) === 'application/jwt' &&\n        (await nonRepudiation?.(response));\n    return result;\n}\nfunction retryable(err, options) {\n    if (options?.DPoP && options.flag !== retry) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.isDPoPNonceError(err);\n    }\n    return false;\n}\nasync function tokenIntrospection(config, token, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.introspectionRequest(as, c, auth, token, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: new URLSearchParams(parameters),\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const result = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processIntrospectionResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    })\n        .catch(errorHandler);\n    oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getContentType(response) === 'application/token-introspection+jwt' &&\n        (await nonRepudiation?.(response));\n    return result;\n}\nconst retry = Symbol();\nasync function genericGrantRequest(config, grantType, parameters, options) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout, decrypt } = int(config);\n    const result = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.genericTokenEndpointRequest(as, c, auth, grantType, new URLSearchParams(parameters), {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => {\n        let recognizedTokenTypes;\n        if (grantType === 'urn:ietf:params:oauth:grant-type:token-exchange') {\n            recognizedTokenTypes = { n_a: () => { } };\n        }\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processGenericTokenEndpointResponse(as, c, response, {\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n            recognizedTokenTypes,\n        });\n    })\n        .catch(errorHandler);\n    addHelpers(result);\n    return result;\n}\nasync function tokenRevocation(config, token, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.revocationRequest(as, c, auth, token, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: new URLSearchParams(parameters),\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processRevocationResponse)\n        .catch(errorHandler);\n}\nasync function fetchProtectedResource(config, accessToken, url, method, body, headers, options) {\n    checkConfig(config);\n    headers ||= new Headers();\n    if (!headers.has('user-agent')) {\n        headers.set('user-agent', USER_AGENT);\n    }\n    const { fetch, tlsOnly, timeout } = int(config);\n    const exec = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.protectedResourceRequest(accessToken, method, url, headers, body, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        signal: signal(timeout),\n    });\n    let result;\n    try {\n        result = await exec;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return fetchProtectedResource(config, accessToken, url, method, body, headers, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    return result;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDb0I7QUFDbEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEdBQUcsUUFBUTtBQUNwQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUM3RztBQUNPO0FBQ1A7QUFDQSxlQUFlLDBEQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSwyREFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUseURBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw4Q0FBVTtBQUNyQjtBQUNPO0FBQ1AsV0FBVyx1REFBbUI7QUFDOUI7QUFDTztBQUNQLFdBQVcsdURBQW1CO0FBQzlCO0FBQ08sdUJBQXVCLHdEQUFvQjtBQUMzQyx5QkFBeUIsMERBQXNCO0FBQy9DLG9CQUFvQixxREFBaUI7QUFDckMsd0JBQXdCLHlEQUFxQjtBQUM3QyxrQkFBa0IsbURBQWU7QUFDakMsdUJBQXVCLHdEQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRCx5QkFBeUIsTUFBTTtBQUMvQjtBQUNB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QixTQUFTLCtEQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsc0VBQ1k7QUFDckMsU0FBUyxvREFBZ0I7QUFDekIsS0FBSztBQUNMO0FBQ0EsSUFBSSx3REFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQseUJBQXlCLHFFQUNXO0FBQ3BDLFNBQVMscURBQWlCO0FBQzFCLFNBQVMsK0RBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxlQUFlLDZFQUF5QztBQUN4RCxhQUFhLG9EQUFnQjtBQUM3QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsV0FBVywyREFDZTtBQUMxQixTQUFTLHFEQUFpQjtBQUMxQixTQUFTLCtEQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxtRUFBK0I7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLGlCQUFpQixrRUFBOEI7QUFDL0MsU0FBUyxxREFBaUI7QUFDMUIsU0FBUywrREFBMkI7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVzdC1leHByZXNzLy4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvYnVpbGQvaW5kZXguanM/YzgzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvYXV0aCBmcm9tICdvYXV0aDR3ZWJhcGknO1xuaW1wb3J0IHsgY29tcGFjdERlY3J5cHQgfSBmcm9tICdqb3NlL2p3ZS9jb21wYWN0L2RlY3J5cHQnO1xuaW1wb3J0IHsgSk9TRUVycm9yIH0gZnJvbSAnam9zZS9lcnJvcnMnO1xubGV0IGhlYWRlcnM7XG5sZXQgVVNFUl9BR0VOVDtcbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudD8uc3RhcnRzV2l0aD8uKCdNb3ppbGxhLzUuMCAnKSkge1xuICAgIGNvbnN0IE5BTUUgPSAnb3BlbmlkLWNsaWVudCc7XG4gICAgY29uc3QgVkVSU0lPTiA9ICd2Ni44LjEnO1xuICAgIFVTRVJfQUdFTlQgPSBgJHtOQU1FfS8ke1ZFUlNJT059YDtcbiAgICBoZWFkZXJzID0geyAndXNlci1hZ2VudCc6IFVTRVJfQUdFTlQgfTtcbn1cbmNvbnN0IGludCA9IChjb25maWcpID0+IHtcbiAgICByZXR1cm4gcHJvcHMuZ2V0KGNvbmZpZyk7XG59O1xubGV0IHByb3BzO1xuZXhwb3J0IHsgQXV0aG9yaXphdGlvblJlc3BvbnNlRXJyb3IsIFJlc3BvbnNlQm9keUVycm9yLCBXV1dBdXRoZW50aWNhdGVDaGFsbGVuZ2VFcnJvciwgfSBmcm9tICdvYXV0aDR3ZWJhcGknO1xubGV0IHRiaTtcbmV4cG9ydCBmdW5jdGlvbiBDbGllbnRTZWNyZXRQb3N0KGNsaWVudFNlY3JldCkge1xuICAgIGlmIChjbGllbnRTZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2F1dGguQ2xpZW50U2VjcmV0UG9zdChjbGllbnRTZWNyZXQpO1xuICAgIH1cbiAgICB0YmkgfHw9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzKSA9PiB7XG4gICAgICAgIGxldCBhdXRoO1xuICAgICAgICBpZiAoIShhdXRoID0gdGJpLmdldChjbGllbnQpKSkge1xuICAgICAgICAgICAgYXNzZXJ0U3RyaW5nKGNsaWVudC5jbGllbnRfc2VjcmV0LCAnXCJtZXRhZGF0YS5jbGllbnRfc2VjcmV0XCInKTtcbiAgICAgICAgICAgIGF1dGggPSBvYXV0aC5DbGllbnRTZWNyZXRQb3N0KGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIHRiaS5zZXQoY2xpZW50LCBhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aChhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKGlucHV0LCBpdCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgc3RyaW5nYCwgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IG5vdCBiZSBlbXB0eWAsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlY3JldEJhc2ljKGNsaWVudFNlY3JldCkge1xuICAgIGlmIChjbGllbnRTZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2F1dGguQ2xpZW50U2VjcmV0QmFzaWMoY2xpZW50U2VjcmV0KTtcbiAgICB9XG4gICAgdGJpIHx8PSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycykgPT4ge1xuICAgICAgICBsZXQgYXV0aDtcbiAgICAgICAgaWYgKCEoYXV0aCA9IHRiaS5nZXQoY2xpZW50KSkpIHtcbiAgICAgICAgICAgIGFzc2VydFN0cmluZyhjbGllbnQuY2xpZW50X3NlY3JldCwgJ1wibWV0YWRhdGEuY2xpZW50X3NlY3JldFwiJyk7XG4gICAgICAgICAgICBhdXRoID0gb2F1dGguQ2xpZW50U2VjcmV0QmFzaWMoY2xpZW50LmNsaWVudF9zZWNyZXQpO1xuICAgICAgICAgICAgdGJpLnNldChjbGllbnQsIGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gQ2xpZW50U2VjcmV0Snd0KGNsaWVudFNlY3JldCwgb3B0aW9ucykge1xuICAgIGlmIChjbGllbnRTZWNyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2F1dGguQ2xpZW50U2VjcmV0Snd0KGNsaWVudFNlY3JldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRiaSB8fD0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMpID0+IHtcbiAgICAgICAgbGV0IGF1dGg7XG4gICAgICAgIGlmICghKGF1dGggPSB0YmkuZ2V0KGNsaWVudCkpKSB7XG4gICAgICAgICAgICBhc3NlcnRTdHJpbmcoY2xpZW50LmNsaWVudF9zZWNyZXQsICdcIm1ldGFkYXRhLmNsaWVudF9zZWNyZXRcIicpO1xuICAgICAgICAgICAgYXV0aCA9IG9hdXRoLkNsaWVudFNlY3JldEp3dChjbGllbnQuY2xpZW50X3NlY3JldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0Ymkuc2V0KGNsaWVudCwgYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGgoYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycyk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBOb25lKCkge1xuICAgIHJldHVybiBvYXV0aC5Ob25lKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gUHJpdmF0ZUtleUp3dChjbGllbnRQcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9hdXRoLlByaXZhdGVLZXlKd3QoY2xpZW50UHJpdmF0ZUtleSwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gVGxzQ2xpZW50QXV0aCgpIHtcbiAgICByZXR1cm4gb2F1dGguVGxzQ2xpZW50QXV0aCgpO1xufVxuZXhwb3J0IGNvbnN0IHNraXBTdGF0ZUNoZWNrID0gb2F1dGguc2tpcFN0YXRlQ2hlY2s7XG5leHBvcnQgY29uc3Qgc2tpcFN1YmplY3RDaGVjayA9IG9hdXRoLnNraXBTdWJqZWN0Q2hlY2s7XG5leHBvcnQgY29uc3QgY3VzdG9tRmV0Y2ggPSBvYXV0aC5jdXN0b21GZXRjaDtcbmV4cG9ydCBjb25zdCBtb2RpZnlBc3NlcnRpb24gPSBvYXV0aC5tb2RpZnlBc3NlcnRpb247XG5leHBvcnQgY29uc3QgY2xvY2tTa2V3ID0gb2F1dGguY2xvY2tTa2V3O1xuZXhwb3J0IGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gb2F1dGguY2xvY2tUb2xlcmFuY2U7XG5jb25zdCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJztcbmNvbnN0IEVSUl9JTlZBTElEX0FSR19UWVBFID0gJ0VSUl9JTlZBTElEX0FSR19UWVBFJztcbmZ1bmN0aW9uIENvZGVkVHlwZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGNhdXNlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oZXJyLCB7IGNvZGUgfSk7XG4gICAgcmV0dXJuIGVycjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpIHtcbiAgICByZXR1cm4gb2F1dGguY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21QS0NFQ29kZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiBvYXV0aC5nZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllcigpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbU5vbmNlKCkge1xuICAgIHJldHVybiBvYXV0aC5nZW5lcmF0ZVJhbmRvbU5vbmNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuIG9hdXRoLmdlbmVyYXRlUmFuZG9tU3RhdGUoKTtcbn1cbmV4cG9ydCBjbGFzcyBDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW9ucz8uY29kZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/Lih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBlKG1zZywgY2F1c2UsIGNvZGUpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEVycm9yKG1zZywgeyBjYXVzZSwgY29kZSB9KTtcbn1cbmZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIENsaWVudEVycm9yIHx8XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIG9hdXRoLlJlc3BvbnNlQm9keUVycm9yIHx8XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIG9hdXRoLkF1dGhvcml6YXRpb25SZXNwb25zZUVycm9yIHx8XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIG9hdXRoLldXV0F1dGhlbnRpY2F0ZUNoYWxsZW5nZUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIG9hdXRoLk9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcikge1xuICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLkhUVFBfUkVRVUVTVF9GT1JCSURERU46XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgnb25seSByZXF1ZXN0cyB0byBIVFRQUyBhcmUgYWxsb3dlZCcsIGVyciwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5SRVFVRVNUX1BST1RPQ09MX0ZPUkJJRERFTjpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCdvbmx5IHJlcXVlc3RzIHRvIEhUVFAgb3IgSFRUUFMgYXJlIGFsbG93ZWQnLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGNhc2Ugb2F1dGguUkVTUE9OU0VfSVNfTk9UX0NPTkZPUk06XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgndW5leHBlY3RlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlJywgZXJyLmNhdXNlLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLlJFU1BPTlNFX0lTX05PVF9KU09OOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3VuZXhwZWN0ZWQgcmVzcG9uc2UgY29udGVudC10eXBlJywgZXJyLmNhdXNlLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLlBBUlNFX0VSUk9SOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3BhcnNpbmcgZXJyb3Igb2NjdXJlZCcsIGVyciwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5JTlZBTElEX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ2ludmFsaWQgcmVzcG9uc2UgZW5jb3VudGVyZWQnLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGNhc2Ugb2F1dGguSldUX0NMQUlNX0NPTVBBUklTT046XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgndW5leHBlY3RlZCBKV1QgY2xhaW0gdmFsdWUgZW5jb3VudGVyZWQnLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGNhc2Ugb2F1dGguSlNPTl9BVFRSSUJVVEVfQ09NUEFSSVNPTjpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCd1bmV4cGVjdGVkIEpTT04gYXR0cmlidXRlIHZhbHVlIGVuY291bnRlcmVkJywgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLkpXVF9USU1FU1RBTVBfQ0hFQ0s6XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgnSldUIHRpbWVzdGFtcCBjbGFpbSB2YWx1ZSBmYWlsZWQgdmFsaWRhdGlvbicsIGVyciwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKGVyci5tZXNzYWdlLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2Ygb2F1dGguVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcikge1xuICAgICAgICB0aHJvdyBlKCd1bnN1cHBvcnRlZCBvcGVyYXRpb24nLCBlcnIsIGVyci5jb2RlKTtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikge1xuICAgICAgICBzd2l0Y2ggKGVyci5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdPcGVyYXRpb25FcnJvcic6XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgncnVudGltZSBvcGVyYXRpb24gZXJyb3InLCBlcnIsIG9hdXRoLlVOU1VQUE9SVEVEX09QRVJBVElPTik7XG4gICAgICAgICAgICBjYXNlICdOb3RTdXBwb3J0ZWRFcnJvcic6XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgncnVudGltZSB1bnN1cHBvcnRlZCBvcGVyYXRpb24nLCBlcnIsIG9hdXRoLlVOU1VQUE9SVEVEX09QRVJBVElPTik7XG4gICAgICAgICAgICBjYXNlICdUaW1lb3V0RXJyb3InOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ29wZXJhdGlvbiB0aW1lZCBvdXQnLCBlcnIsICdPQVVUSF9USU1FT1VUJyk7XG4gICAgICAgICAgICBjYXNlICdBYm9ydEVycm9yJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCdvcGVyYXRpb24gYWJvcnRlZCcsIGVyciwgJ09BVVRIX0FCT1JUJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IENsaWVudEVycm9yKCdzb21ldGhpbmcgd2VudCB3cm9uZycsIHsgY2F1c2U6IGVyciB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21EUG9QS2V5UGFpcihhbGcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb2F1dGhcbiAgICAgICAgLmdlbmVyYXRlS2V5UGFpcihhbGcgPz8gJ0VTMjU2Jywge1xuICAgICAgICBleHRyYWN0YWJsZTogb3B0aW9ucz8uZXh0cmFjdGFibGUsXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG59XG5mdW5jdGlvbiBoYW5kbGVFbnRyYUlkKHNlcnZlciwgYXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoc2VydmVyLm9yaWdpbiA9PT0gJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbScgJiZcbiAgICAgICAgKCFvcHRpb25zPy5hbGdvcml0aG0gfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdvaWRjJykpIHtcbiAgICAgICAgYXNba0VudHJhSWRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUIyQ2xvZ2luKHNlcnZlciwgb3B0aW9ucykge1xuICAgIGlmIChzZXJ2ZXIuaG9zdG5hbWUuZW5kc1dpdGgoJy5iMmNsb2dpbi5jb20nKSAmJlxuICAgICAgICAoIW9wdGlvbnM/LmFsZ29yaXRobSB8fCBvcHRpb25zLmFsZ29yaXRobSA9PT0gJ29pZGMnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGR5bmFtaWNDbGllbnRSZWdpc3RyYXRpb24oc2VydmVyLCBtZXRhZGF0YSwgY2xpZW50QXV0aGVudGljYXRpb24sIG9wdGlvbnMpIHtcbiAgICBsZXQgYXM7XG4gICAgaWYgKG9wdGlvbnM/LmZsYWcgPT09IHJldHJ5KSB7XG4gICAgICAgIGFzID0gb3B0aW9ucy5hcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzID0gYXdhaXQgcGVyZm9ybURpc2NvdmVyeShzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBjbG9ja1NrZXcgPSBtZXRhZGF0YVtvYXV0aC5jbG9ja1NrZXddID8/IDA7XG4gICAgY29uc3QgY2xvY2tUb2xlcmFuY2UgPSBtZXRhZGF0YVtvYXV0aC5jbG9ja1RvbGVyYW5jZV0gPz8gMzA7XG4gICAgbWV0YWRhdGEgPSBzdHJ1Y3R1cmVkQ2xvbmUobWV0YWRhdGEpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zPy50aW1lb3V0ID8/IDMwO1xuICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCAqIDEwMDApO1xuICAgIGxldCByZWdpc3RlcmVkO1xuICAgIHRyeSB7XG4gICAgICAgIHJlZ2lzdGVyZWQgPSBhd2FpdCBvYXV0aFxuICAgICAgICAgICAgLmR5bmFtaWNDbGllbnRSZWdpc3RyYXRpb25SZXF1ZXN0KGFzLCBtZXRhZGF0YSwge1xuICAgICAgICAgICAgaW5pdGlhbEFjY2Vzc1Rva2VuOiBvcHRpb25zPy5pbml0aWFsQWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBEUG9QOiBvcHRpb25zPy5EUG9QLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBvcHRpb25zPy5bY3VzdG9tRmV0Y2hdLFxuICAgICAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106IG9wdGlvbnM/LmV4ZWN1dGU/LmluY2x1ZGVzKGFsbG93SW5zZWN1cmVSZXF1ZXN0cyksXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihvYXV0aC5wcm9jZXNzRHluYW1pY0NsaWVudFJlZ2lzdHJhdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uKHNlcnZlciwgbWV0YWRhdGEsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZWdpc3RlcmVkW29hdXRoLmNsb2NrU2tld10gPSBjbG9ja1NrZXc7XG4gICAgcmVnaXN0ZXJlZFtvYXV0aC5jbG9ja1RvbGVyYW5jZV0gPSBjbG9ja1RvbGVyYW5jZTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDb25maWd1cmF0aW9uKGFzLCByZWdpc3RlcmVkLmNsaWVudF9pZCwgcmVnaXN0ZXJlZCwgY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgIGxldCBpbnRlcm5hbHMgPSBpbnQoaW5zdGFuY2UpO1xuICAgIGlmIChvcHRpb25zPy5bY3VzdG9tRmV0Y2hdKSB7XG4gICAgICAgIGludGVybmFscy5mZXRjaCA9IG9wdGlvbnNbY3VzdG9tRmV0Y2hdO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8udGltZW91dCkge1xuICAgICAgICBpbnRlcm5hbHMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmV4ZWN1dGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHRlbnNpb24gb2Ygb3B0aW9ucy5leGVjdXRlKSB7XG4gICAgICAgICAgICBleHRlbnNpb24oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb3Zlcnkoc2VydmVyLCBjbGllbnRJZCwgbWV0YWRhdGEsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXMgPSBhd2FpdCBwZXJmb3JtRGlzY292ZXJ5KHNlcnZlciwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ29uZmlndXJhdGlvbihhcywgY2xpZW50SWQsIG1ldGFkYXRhLCBjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgbGV0IGludGVybmFscyA9IGludChpbnN0YW5jZSk7XG4gICAgaWYgKG9wdGlvbnM/LltjdXN0b21GZXRjaF0pIHtcbiAgICAgICAgaW50ZXJuYWxzLmZldGNoID0gb3B0aW9uc1tjdXN0b21GZXRjaF07XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy50aW1lb3V0KSB7XG4gICAgICAgIGludGVybmFscy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uZXhlY3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBvcHRpb25zLmV4ZWN1dGUpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybURpc2NvdmVyeShzZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShzZXJ2ZXIgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInNlcnZlclwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlID0gIXNlcnZlci5ocmVmLmluY2x1ZGVzKCcvLndlbGwta25vd24vJyk7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnM/LnRpbWVvdXQgPz8gMzA7XG4gICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0ICogMTAwMCk7XG4gICAgY29uc3QgYXMgPSBhd2FpdCAocmVzb2x2ZVxuICAgICAgICA/IG9hdXRoLmRpc2NvdmVyeVJlcXVlc3Qoc2VydmVyLCB7XG4gICAgICAgICAgICBhbGdvcml0aG06IG9wdGlvbnM/LmFsZ29yaXRobSxcbiAgICAgICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IG9wdGlvbnM/LltjdXN0b21GZXRjaF0sXG4gICAgICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogb3B0aW9ucz8uZXhlY3V0ZT8uaW5jbHVkZXMoYWxsb3dJbnNlY3VyZVJlcXVlc3RzKSxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICB9KVxuICAgICAgICA6IChvcHRpb25zPy5bY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSgoKCkgPT4ge1xuICAgICAgICAgICAgb2F1dGguY2hlY2tQcm90b2NvbChzZXJ2ZXIsIG9wdGlvbnM/LmV4ZWN1dGU/LmluY2x1ZGVzKGFsbG93SW5zZWN1cmVSZXF1ZXN0cykgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlci5ocmVmO1xuICAgICAgICB9KSgpLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMobmV3IEhlYWRlcnMoeyBhY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4uaGVhZGVycyB9KS5lbnRyaWVzKCkpLFxuICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfSkpXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gb2F1dGgucHJvY2Vzc0Rpc2NvdmVyeVJlc3BvbnNlKG9hdXRoLl9ub2Rpc2NvdmVyeWNoZWNrLCByZXNwb25zZSkpXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGlmIChyZXNvbHZlICYmIG5ldyBVUkwoYXMuaXNzdWVyKS5ocmVmICE9PSBzZXJ2ZXIuaHJlZikge1xuICAgICAgICBoYW5kbGVFbnRyYUlkKHNlcnZlciwgYXMsIG9wdGlvbnMpIHx8XG4gICAgICAgICAgICBoYW5kbGVCMkNsb2dpbihzZXJ2ZXIsIG9wdGlvbnMpIHx8XG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDbGllbnRFcnJvcignZGlzY292ZXJlZCBtZXRhZGF0YSBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGlzc3VlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogb2F1dGguSlNPTl9BVFRSSUJVVEVfQ09NUEFSSVNPTixcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBzZXJ2ZXIuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnaXNzdWVyJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJldHVybiBhcztcbn1cbmZ1bmN0aW9uIGlzUnNhT2FlcChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5uYW1lID09PSAnUlNBLU9BRVAnO1xufVxuZnVuY3Rpb24gaXNFY2RoKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0Lm5hbWUgPT09ICdFQ0RIJztcbn1cbmNvbnN0IGVjZGhFcyA9ICdFQ0RILUVTJztcbmNvbnN0IGVjZGhFc0ExMjhLdyA9ICdFQ0RILUVTK0ExMjhLVyc7XG5jb25zdCBlY2RoRXNBMTkyS3cgPSAnRUNESC1FUytBMTkyS1cnO1xuY29uc3QgZWNkaEVzQTI1Nkt3ID0gJ0VDREgtRVMrQTI1NktXJztcbmZ1bmN0aW9uIGNoZWNrRWNkaEFsZyhhbGdzLCBhbGcsIHBrKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBhbGdzLmFkZChlY2RoRXMpO1xuICAgICAgICAgICAgYWxncy5hZGQoZWNkaEVzQTEyOEt3KTtcbiAgICAgICAgICAgIGFsZ3MuYWRkKGVjZGhFc0ExOTJLdyk7XG4gICAgICAgICAgICBhbGdzLmFkZChlY2RoRXNBMjU2S3cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZWNkaEVzOlxuICAgICAgICBjYXNlIGVjZGhFc0ExMjhLdzpcbiAgICAgICAgY2FzZSBlY2RoRXNBMTkyS3c6XG4gICAgICAgIGNhc2UgZWNkaEVzQTI1Nkt3OlxuICAgICAgICAgICAgYWxncy5hZGQoYWxnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGFsZycsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgeyBwayB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlRGVjcnlwdGluZ1Jlc3BvbnNlcyhjb25maWcsIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtcyA9IFtcbiAgICAnQTEyOEdDTScsXG4gICAgJ0ExOTJHQ00nLFxuICAgICdBMjU2R0NNJyxcbiAgICAnQTEyOENCQy1IUzI1NicsXG4gICAgJ0ExOTJDQkMtSFMzODQnLFxuICAgICdBMjU2Q0JDLUhTNTEyJyxcbl0sIC4uLmtleXMpIHtcbiAgICBpZiAoaW50KGNvbmZpZykuZGVjcnlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuYWJsZURlY3J5cHRpbmdSZXNwb25zZXMgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgZ2l2ZW4gQ29uZmlndXJhdGlvbiBpbnN0YW5jZSBvbmNlJyk7XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignbm8ga2V5cyB3ZXJlIHByb3ZpZGVkJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG4gICAgY29uc3QgYWxncyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgZm9yIChjb25zdCBwayBvZiBrZXlzKSB7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGlmICgna2V5JyBpbiBwaykge1xuICAgICAgICAgICAga2V5ID0geyBrZXk6IHBrLmtleSB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBway5hbGcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGtleS5hbGcgPSBway5hbGc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBrLmtpZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAga2V5LmtpZCA9IHBrLmtpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHsga2V5OiBwayB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkua2V5LnR5cGUgIT09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ29ubHkgcHJpdmF0ZSBrZXlzIG11c3QgYmUgcHJvdmlkZWQnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JzYU9hZXAoa2V5LmtleS5hbGdvcml0aG0pKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleS5rZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0xJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtNTEyJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxnID0gJ1JTQS1PQUVQJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNoYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzaGEgPSBwYXJzZUludChrZXkua2V5LmFsZ29yaXRobS5oYXNoLm5hbWUuc2xpY2UoLTMpLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGcgPSBgJHthbGd9LSR7c2hhfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2V5LmFsZyB8fD0gYWxnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxnICE9PSBrZXkuYWxnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGFsZycsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFsZ3MuYWRkKGtleS5hbGcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ29ubHkgU0hBLTUxMiwgU0hBLTM4NCwgU0hBLTI1NiwgYW5kIFNIQS0xIFJTQS1PQUVQIGtleXMgYXJlIHN1cHBvcnRlZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFY2RoKGtleS5rZXkuYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgaWYgKGtleS5rZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUgIT09ICdQLTI1NicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignT25seSBQLTI1NiBFQ0RIIGtleXMgYXJlIHN1cHBvcnRlZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0VjZGhBbGcoYWxncywga2V5LmFsZywgcGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5rZXkuYWxnb3JpdGhtLm5hbWUgPT09ICdYMjU1MTknKSB7XG4gICAgICAgICAgICBjaGVja0VjZGhBbGcoYWxncywga2V5LmFsZywgcGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ29ubHkgUlNBLU9BRVAsIEVDREgsIG9yIFgyNTUxOSBrZXlzIGFyZSBzdXBwb3J0ZWQnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChrZXkpO1xuICAgIH1cbiAgICBpbnQoY29uZmlnKS5kZWNyeXB0ID0gYXN5bmMgKGp3ZSkgPT4gZGVjcnlwdChub3JtYWxpemVkLCBqd2UsIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtcywgWy4uLmFsZ3NdKS5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuZnVuY3Rpb24gY2hlY2tDcnlwdG9LZXkoa2V5LCBhbGcsIGVwaykge1xuICAgIGlmIChhbGcuc3RhcnRzV2l0aCgnUlNBLU9BRVAnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFsZy5zdGFydHNXaXRoKCdFQ0RILUVTJykpIHtcbiAgICAgICAgaWYgKGtleS5hbGdvcml0aG0ubmFtZSAhPT0gJ0VDREgnICYmIGtleS5hbGdvcml0aG0ubmFtZSAhPT0gJ1gyNTUxOScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmFsZ29yaXRobS5uYW1lID09PSAnRUNESCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcGs/LmNydiA9PT0ga2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuYWxnb3JpdGhtLm5hbWUgPT09ICdYMjU1MTknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXBrPy5jcnYgPT09ICdYMjU1MTknO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENyeXB0b0tleUZvckRlY3J5cHRpb24oa2V5cywgYWxnLCBraWQsIGVwaykge1xuICAgIGNvbnN0IHsgMDoga2V5LCBsZW5ndGggfSA9IGtleXMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGtpZCAhPT0ga2V5LmtpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuYWxnICYmIGFsZyAhPT0ga2V5LmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja0NyeXB0b0tleShrZXkua2V5LCBhbGcsIGVwayk7XG4gICAgfSk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgdGhyb3cgZSgnbm8gYXBwbGljYWJsZSBkZWNyeXB0aW9uIGtleSBzZWxlY3RlZCcsIHVuZGVmaW5lZCwgJ09BVVRIX0RFQ1JZUFRJT05fRkFJTEVEJyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgZSgnbXVsdGlwbGUgYXBwbGljYWJsZSBkZWNyeXB0aW9uIGtleXMgc2VsZWN0ZWQnLCB1bmRlZmluZWQsICdPQVVUSF9ERUNSWVBUSU9OX0ZBSUxFRCcpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5LmtleTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoa2V5cywgandlLCBjb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobXMsIGtleU1hbmFnZW1lbnRBbGdvcml0aG1zKSB7XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKChhd2FpdCBjb21wYWN0RGVjcnlwdChqd2UsIChoZWFkZXIpID0+IHtcbiAgICAgICAgY29uc3QgeyBraWQsIGFsZywgZXBrIH0gPSBoZWFkZXI7XG4gICAgICAgIHJldHVybiBzZWxlY3RDcnlwdG9LZXlGb3JEZWNyeXB0aW9uKGtleXMsIGFsZywga2lkLCBlcGspO1xuICAgIH0sIHsga2V5TWFuYWdlbWVudEFsZ29yaXRobXMsIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtcyB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBKT1NFRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGUoJ2RlY3J5cHRpb24gZmFpbGVkJywgZXJyLCAnT0FVVEhfREVDUllQVElPTl9GQUlMRUQnKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9KSkucGxhaW50ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlckhlbHBlcnMobWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBwb3J0c1BLQ0U6IHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlKG1ldGhvZCA9ICdTMjU2Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQ/LmluY2x1ZGVzKG1ldGhvZCkgPT09IHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkU2VydmVySGVscGVycyhtZXRhZGF0YSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1ldGFkYXRhLCBnZXRTZXJ2ZXJIZWxwZXJzKG1ldGFkYXRhKSk7XG59XG5jb25zdCBrRW50cmFJZCA9IFN5bWJvbCgpO1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgY2xpZW50SWQsIG1ldGFkYXRhLCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGNsaWVudElkICE9PSAnc3RyaW5nJyB8fCAhY2xpZW50SWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjbGllbnRJZFwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IHsgY2xpZW50X3NlY3JldDogbWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGE/LmNsaWVudF9pZCAhPT0gdW5kZWZpbmVkICYmIGNsaWVudElkICE9PSBtZXRhZGF0YS5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImNsaWVudElkXCIgYW5kIFwibWV0YWRhdGEuY2xpZW50X2lkXCIgbXVzdCBiZSB0aGUgc2FtZScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgICAgICAgLi4uc3RydWN0dXJlZENsb25lKG1ldGFkYXRhKSxcbiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIGNsaWVudFtvYXV0aC5jbG9ja1NrZXddID0gbWV0YWRhdGE/LltvYXV0aC5jbG9ja1NrZXddID8/IDA7XG4gICAgICAgIGNsaWVudFtvYXV0aC5jbG9ja1RvbGVyYW5jZV0gPSBtZXRhZGF0YT8uW29hdXRoLmNsb2NrVG9sZXJhbmNlXSA/PyAzMDtcbiAgICAgICAgbGV0IGF1dGg7XG4gICAgICAgIGlmIChjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgYXV0aCA9IGNsaWVudEF1dGhlbnRpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnQuY2xpZW50X3NlY3JldCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBjbGllbnQuY2xpZW50X3NlY3JldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhdXRoID0gQ2xpZW50U2VjcmV0UG9zdChjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdXRoID0gTm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjID0gT2JqZWN0LmZyZWV6ZShjbGllbnQpO1xuICAgICAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShzZXJ2ZXIpO1xuICAgICAgICBpZiAoa0VudHJhSWQgaW4gc2VydmVyKSB7XG4gICAgICAgICAgICBjbG9uZVtvYXV0aC5fZXhwZWN0ZWRJc3N1ZXJdID0gKHsgY2xhaW1zOiB7IHRpZCB9IH0pID0+IHNlcnZlci5pc3N1ZXIucmVwbGFjZSgne3RlbmFudGlkfScsIHRpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzID0gT2JqZWN0LmZyZWV6ZShjbG9uZSk7XG4gICAgICAgIHByb3BzIHx8PSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBwcm9wcy5zZXQodGhpcywge1xuICAgICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIHRsc09ubHk6IHRydWUsXG4gICAgICAgICAgICBqd2tzQ2FjaGU6IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VydmVyTWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gc3RydWN0dXJlZENsb25lKGludCh0aGlzKS5hcyk7XG4gICAgICAgIGFkZFNlcnZlckhlbHBlcnMobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGNsaWVudE1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHN0cnVjdHVyZWRDbG9uZShpbnQodGhpcykuYyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgZ2V0IHRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiBpbnQodGhpcykudGltZW91dDtcbiAgICB9XG4gICAgc2V0IHRpbWVvdXQodmFsdWUpIHtcbiAgICAgICAgaW50KHRoaXMpLnRpbWVvdXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IFtjdXN0b21GZXRjaF0oKSB7XG4gICAgICAgIHJldHVybiBpbnQodGhpcykuZmV0Y2g7XG4gICAgfVxuICAgIHNldCBbY3VzdG9tRmV0Y2hdKHZhbHVlKSB7XG4gICAgICAgIGludCh0aGlzKS5mZXRjaCA9IHZhbHVlO1xuICAgIH1cbn1cbk9iamVjdC5mcmVlemUoQ29uZmlndXJhdGlvbi5wcm90b3R5cGUpO1xuZnVuY3Rpb24gZ2V0SGVscGVycyhyZXNwb25zZSkge1xuICAgIGxldCBleHAgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHJlc3BvbnNlLmV4cGlyZXNfaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBub3cuc2V0U2Vjb25kcyhub3cuZ2V0U2Vjb25kcygpICsgcmVzcG9uc2UuZXhwaXJlc19pbik7XG4gICAgICAgIGV4cCA9IG5vdy5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyZXNJbjoge1xuICAgICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwID4gbm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoZXhwIC0gbm93KSAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhaW1zOiB7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2F1dGguZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZEhlbHBlcnMocmVzcG9uc2UpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXNwb25zZSwgZ2V0SGVscGVycyhyZXNwb25zZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERQb1BIYW5kbGUoY29uZmlnLCBrZXlQYWlyLCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICByZXR1cm4gb2F1dGguRFBvUChpbnQoY29uZmlnKS5jLCBrZXlQYWlyLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJldHJ5QWZ0ZXIocmVzcG9uc2UsIGN1cnJlbnRJbnRlcnZhbCwgc2lnbmFsLCB0aHJvd0lmSW52YWxpZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdyZXRyeS1hZnRlcicpPy50cmltKCk7XG4gICAgaWYgKHJldHJ5QWZ0ZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkZWxheVNlY29uZHM7XG4gICAgaWYgKC9eXFxkKyQvLnRlc3QocmV0cnlBZnRlcikpIHtcbiAgICAgICAgZGVsYXlTZWNvbmRzID0gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gbmV3IERhdGUocmV0cnlBZnRlcik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmV0cnlEYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBkZWxheU1zID0gcmV0cnlEYXRlLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCk7XG4gICAgICAgICAgICBpZiAoZGVsYXlNcyA+IDApIHtcbiAgICAgICAgICAgICAgICBkZWxheVNlY29uZHMgPSBNYXRoLmNlaWwoZGVsYXlNcyAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aHJvd0lmSW52YWxpZCAmJiAhTnVtYmVyLmlzRmluaXRlKGRlbGF5U2Vjb25kcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IG9hdXRoLk9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcignaW52YWxpZCBSZXRyeS1BZnRlciBoZWFkZXIgdmFsdWUnLCB7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlbGF5U2Vjb25kcyA+IGN1cnJlbnRJbnRlcnZhbCkge1xuICAgICAgICBhd2FpdCB3YWl0KGRlbGF5U2Vjb25kcyAtIGN1cnJlbnRJbnRlcnZhbCwgc2lnbmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3YWl0KGR1cmF0aW9uLCBzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB3YWl0U3RlcCA9IChyZW1haW5pbmcpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXYWl0ID0gTWF0aC5taW4ocmVtYWluaW5nLCA1KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gd2FpdFN0ZXAocmVtYWluaW5nIC0gY3VycmVudFdhaXQpLCBjdXJyZW50V2FpdCAqIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICB3YWl0U3RlcChkdXJhdGlvbik7XG4gICAgfSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9sbERldmljZUF1dGhvcml6YXRpb25HcmFudChjb25maWcsIGRldmljZUF1dGhvcml6YXRpb25SZXNwb25zZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgbGV0IGludGVydmFsID0gZGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlLmludGVydmFsID8/IDU7XG4gICAgY29uc3QgcG9sbGluZ1NpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbCA/P1xuICAgICAgICBBYm9ydFNpZ25hbC50aW1lb3V0KGRldmljZUF1dGhvcml6YXRpb25SZXNwb25zZS5leHBpcmVzX2luICogMTAwMCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgd2FpdChpbnRlcnZhbCwgcG9sbGluZ1NpZ25hbCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmV0cnlQb2xsID0gKHVwZGF0ZWRJbnRlcnZhbCwgZmxhZykgPT4gcG9sbERldmljZUF1dGhvcml6YXRpb25HcmFudChjb25maWcsIHtcbiAgICAgICAgLi4uZGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlLFxuICAgICAgICBpbnRlcnZhbDogdXBkYXRlZEludGVydmFsLFxuICAgIH0sIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBwb2xsaW5nU2lnbmFsLFxuICAgICAgICBmbGFnLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmRldmljZUNvZGVHcmFudFJlcXVlc3QoYXMsIGMsIGF1dGgsIGRldmljZUF1dGhvcml6YXRpb25SZXNwb25zZS5kZXZpY2VfY29kZSwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogcG9sbGluZ1NpZ25hbC5hYm9ydGVkID8gcG9sbGluZ1NpZ25hbCA6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDMgJiYgcmVzcG9uc2UuaGVhZGVycy5oYXMoJ3JldHJ5LWFmdGVyJykpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlUmV0cnlBZnRlcihyZXNwb25zZSwgaW50ZXJ2YWwsIHBvbGxpbmdTaWduYWwsIHRydWUpO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5ib2R5Py5jYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5UG9sbChpbnRlcnZhbCk7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBvYXV0aC5wcm9jZXNzRGV2aWNlQ29kZVJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSwge1xuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5UG9sbChpbnRlcnZhbCwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBvYXV0aC5SZXNwb25zZUJvZHlFcnJvcikge1xuICAgICAgICAgICAgc3dpdGNoIChlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzbG93X2Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCArPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6YXRpb25fcGVuZGluZyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZVJldHJ5QWZ0ZXIoZXJyLnJlc3BvbnNlLCBpbnRlcnZhbCwgcG9sbGluZ1NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRyeVBvbGwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXN1bHQuaWRfdG9rZW4gJiYgKGF3YWl0IG5vblJlcHVkaWF0aW9uPy4ocmVzcG9uc2UpKTtcbiAgICBhZGRIZWxwZXJzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWF0ZURldmljZUF1dGhvcml6YXRpb24oY29uZmlnLCBwYXJhbWV0ZXJzKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCB9ID0gaW50KGNvbmZpZyk7XG4gICAgcmV0dXJuIG9hdXRoXG4gICAgICAgIC5kZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdChhcywgYywgYXV0aCwgcGFyYW1ldGVycywge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiBvYXV0aC5wcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSkpXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYXRlQmFja2NoYW5uZWxBdXRoZW50aWNhdGlvbihjb25maWcsIHBhcmFtZXRlcnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0IH0gPSBpbnQoY29uZmlnKTtcbiAgICByZXR1cm4gb2F1dGhcbiAgICAgICAgLmJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXF1ZXN0KGFzLCBjLCBhdXRoLCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IG9hdXRoLnByb2Nlc3NCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlKSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9sbEJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudChjb25maWcsIGJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgbGV0IGludGVydmFsID0gYmFja2NoYW5uZWxBdXRoZW50aWNhdGlvblJlc3BvbnNlLmludGVydmFsID8/IDU7XG4gICAgY29uc3QgcG9sbGluZ1NpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbCA/P1xuICAgICAgICBBYm9ydFNpZ25hbC50aW1lb3V0KGJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZS5leHBpcmVzX2luICogMTAwMCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgd2FpdChpbnRlcnZhbCwgcG9sbGluZ1NpZ25hbCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmV0cnlQb2xsID0gKHVwZGF0ZWRJbnRlcnZhbCwgZmxhZykgPT4gcG9sbEJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudChjb25maWcsIHtcbiAgICAgICAgLi4uYmFja2NoYW5uZWxBdXRoZW50aWNhdGlvblJlc3BvbnNlLFxuICAgICAgICBpbnRlcnZhbDogdXBkYXRlZEludGVydmFsLFxuICAgIH0sIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBwb2xsaW5nU2lnbmFsLFxuICAgICAgICBmbGFnLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlcXVlc3QoYXMsIGMsIGF1dGgsIGJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZS5hdXRoX3JlcV9pZCwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogcG9sbGluZ1NpZ25hbC5hYm9ydGVkID8gcG9sbGluZ1NpZ25hbCA6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDMgJiYgcmVzcG9uc2UuaGVhZGVycy5oYXMoJ3JldHJ5LWFmdGVyJykpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlUmV0cnlBZnRlcihyZXNwb25zZSwgaW50ZXJ2YWwsIHBvbGxpbmdTaWduYWwsIHRydWUpO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5ib2R5Py5jYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5UG9sbChpbnRlcnZhbCk7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBvYXV0aC5wcm9jZXNzQmFja2NoYW5uZWxBdXRoZW50aWNhdGlvbkdyYW50UmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlLCB7XG4gICAgICAgIFtvYXV0aC5qd2VEZWNyeXB0XTogZGVjcnlwdCxcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHA7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldHJ5YWJsZShlcnIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlQb2xsKGludGVydmFsLCByZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIG9hdXRoLlJlc3BvbnNlQm9keUVycm9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Nsb3dfZG93bic6XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICs9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXV0aG9yaXphdGlvbl9wZW5kaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlUmV0cnlBZnRlcihlcnIucmVzcG9uc2UsIGludGVydmFsLCBwb2xsaW5nU2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5UG9sbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIHJlc3VsdC5pZF90b2tlbiAmJiAoYXdhaXQgbm9uUmVwdWRpYXRpb24/LihyZXNwb25zZSkpO1xuICAgIGFkZEhlbHBlcnMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFsbG93SW5zZWN1cmVSZXF1ZXN0cyhjb25maWcpIHtcbiAgICBpbnQoY29uZmlnKS50bHNPbmx5ID0gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0Sndrc0NhY2hlKGNvbmZpZywgandrc0NhY2hlKSB7XG4gICAgaW50KGNvbmZpZykuandrc0NhY2hlID0gc3RydWN0dXJlZENsb25lKGp3a3NDYWNoZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Sndrc0NhY2hlKGNvbmZpZykge1xuICAgIGNvbnN0IGNhY2hlID0gaW50KGNvbmZpZykuandrc0NhY2hlO1xuICAgIGlmIChjYWNoZS51YXQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZU5vblJlcHVkaWF0aW9uQ2hlY2tzKGNvbmZpZykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgaW50KGNvbmZpZykubm9uUmVwdWRpYXRpb24gPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgeyBhcywgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQsIGp3a3NDYWNoZSB9ID0gaW50KGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBvYXV0aFxuICAgICAgICAgICAgLnZhbGlkYXRlQXBwbGljYXRpb25MZXZlbFNpZ25hdHVyZShhcywgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICAgICAgICAgIFtvYXV0aC5qd2tzQ2FjaGVdOiBqd2tzQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUp3dFJlc3BvbnNlTW9kZShjb25maWcpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgaHlicmlkLCBpbXBsaWNpdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgaWYgKGh5YnJpZCB8fCBpbXBsaWNpdCkge1xuICAgICAgICB0aHJvdyBlKCdKQVJNIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGEgaHlicmlkIG9yIGltcGxpY2l0IHJlc3BvbnNlIHR5cGVzJywgdW5kZWZpbmVkLCBvYXV0aC5VTlNVUFBPUlRFRF9PUEVSQVRJT04pO1xuICAgIH1cbiAgICBpbnQoY29uZmlnKS5qYXJtID0gKGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWRTdGF0ZSkgPT4gdmFsaWRhdGVKQVJNUmVzcG9uc2UoY29uZmlnLCBhdXRob3JpemF0aW9uUmVzcG9uc2UsIGV4cGVjdGVkU3RhdGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZURldGFjaGVkU2lnbmF0dXJlUmVzcG9uc2VDaGVja3MoY29uZmlnKSB7XG4gICAgaWYgKCFpbnQoY29uZmlnKS5oeWJyaWQpIHtcbiAgICAgICAgdGhyb3cgZSgnXCJjb2RlIGlkX3Rva2VuXCIgcmVzcG9uc2UgdHlwZSBtdXN0IGJlIGNvbmZpZ3VyZWQgdG8gYmUgdXNlZCBmaXJzdCcsIHVuZGVmaW5lZCwgb2F1dGguVU5TVVBQT1JURURfT1BFUkFUSU9OKTtcbiAgICB9XG4gICAgaW50KGNvbmZpZykuaHlicmlkID0gKGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlKSA9PiB2YWxpZGF0ZUNvZGVJZFRva2VuUmVzcG9uc2UoY29uZmlnLCBhdXRob3JpemF0aW9uUmVzcG9uc2UsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgdHJ1ZSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wbGljaXRBdXRoZW50aWNhdGlvbihjb25maWcsIGN1cnJlbnRVcmwsIGV4cGVjdGVkTm9uY2UsIGNoZWNrcykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKCEoY3VycmVudFVybCBpbnN0YW5jZW9mIFVSTCkgJiZcbiAgICAgICAgIXdlYkluc3RhbmNlT2YoY3VycmVudFVybCwgJ1JlcXVlc3QnKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjdXJyZW50VXJsXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwsIG9yIFJlcXVlc3QnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWROb25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiZXhwZWN0ZWROb25jZVwiIG11c3QgYmUgYSBzdHJpbmcnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYXMsIGMsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0LCBkZWNyeXB0LCBpbXBsaWNpdCwgandrc0NhY2hlIH0gPSBpbnQoY29uZmlnKTtcbiAgICBpZiAoIWltcGxpY2l0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltcGxpY2l0QXV0aGVudGljYXRpb24oKSBjYW5ub3QgYmUgdXNlZCBieSBjbGllbnRzIHVzaW5nIGZsb3dzIG90aGVyIHRoYW4gcmVzcG9uc2VfdHlwZT1pZF90b2tlbicpO1xuICAgIH1cbiAgICBsZXQgcGFyYW1zO1xuICAgIGlmICghKGN1cnJlbnRVcmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjdXJyZW50VXJsO1xuICAgICAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobmV3IFVSTChyZXF1ZXN0LnVybCkuaGFzaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IG9hdXRoLmZvcm1Qb3N0UmVzcG9uc2UocmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcigndW5leHBlY3RlZCBSZXF1ZXN0IEhUVFAgbWV0aG9kJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhjdXJyZW50VXJsLmhhc2guc2xpY2UoMSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkZWNveSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgIGRlY295LmRlbGV0ZSgnaWRfdG9rZW4nKTtcbiAgICAgICAgICAgIG9hdXRoLnZhbGlkYXRlQXV0aFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAuLi5hcyxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LCBjLCBkZWNveSwgY2hlY2tzPy5leHBlY3RlZFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkZWNveSA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiAnZGVjb3knLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgIGlkX3Rva2VuOiBwYXJhbXMuZ2V0KCdpZF90b2tlbicpLFxuICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IG9hdXRoLnByb2Nlc3NBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlKGFzLCBjLCBkZWNveSwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkTm9uY2UsXG4gICAgICAgICAgICAgICAgbWF4QWdlOiBjaGVja3M/Lm1heEFnZSxcbiAgICAgICAgICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IG9hdXRoLnZhbGlkYXRlQXBwbGljYXRpb25MZXZlbFNpZ25hdHVyZShhcywgZGVjb3ksIHtcbiAgICAgICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgICAgICAgICAgICAgW29hdXRoLmp3a3NDYWNoZV06IGp3a3NDYWNoZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9hdXRoLmdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb2RlSWRUb2tlblJlc3BvbnNlVHlwZShjb25maWcpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgamFybSwgaW1wbGljaXQgfSA9IGludChjb25maWcpO1xuICAgIGlmIChqYXJtIHx8IGltcGxpY2l0KSB7XG4gICAgICAgIHRocm93IGUoJ1wiY29kZSBpZF90b2tlblwiIHJlc3BvbnNlIHR5cGUgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggSkFSTSBvciBpbXBsaWNpdCByZXNwb25zZSB0eXBlJywgdW5kZWZpbmVkLCBvYXV0aC5VTlNVUFBPUlRFRF9PUEVSQVRJT04pO1xuICAgIH1cbiAgICBpbnQoY29uZmlnKS5oeWJyaWQgPSAoYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UpID0+IHZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZShjb25maWcsIGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlLCBmYWxzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlSWRUb2tlblJlc3BvbnNlVHlwZShjb25maWcpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgamFybSwgaHlicmlkIH0gPSBpbnQoY29uZmlnKTtcbiAgICBpZiAoamFybSB8fCBoeWJyaWQpIHtcbiAgICAgICAgdGhyb3cgZSgnXCJpZF90b2tlblwiIHJlc3BvbnNlIHR5cGUgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggSkFSTSBvciBoeWJyaWQgcmVzcG9uc2UgdHlwZScsIHVuZGVmaW5lZCwgb2F1dGguVU5TVVBQT1JURURfT1BFUkFUSU9OKTtcbiAgICB9XG4gICAgaW50KGNvbmZpZykuaW1wbGljaXQgPSB0cnVlO1xufVxuZnVuY3Rpb24gc3RyaXBQYXJhbXModXJsKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHVybC5zZWFyY2ggPSAnJztcbiAgICB1cmwuaGFzaCA9ICcnO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbn1cbmZ1bmN0aW9uIHdlYkluc3RhbmNlT2YoaW5wdXQsIHRvU3RyaW5nVGFnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dClbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gdG9TdHJpbmdUYWc7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRob3JpemF0aW9uQ29kZUdyYW50KGNvbmZpZywgY3VycmVudFVybCwgY2hlY2tzLCB0b2tlbkVuZHBvaW50UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKG9wdGlvbnM/LmZsYWcgIT09IHJldHJ5ICYmXG4gICAgICAgICEoY3VycmVudFVybCBpbnN0YW5jZW9mIFVSTCkgJiZcbiAgICAgICAgIXdlYkluc3RhbmNlT2YoY3VycmVudFVybCwgJ1JlcXVlc3QnKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjdXJyZW50VXJsXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwsIG9yIFJlcXVlc3QnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGxldCBhdXRoUmVzcG9uc2U7XG4gICAgbGV0IHJlZGlyZWN0VXJpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCBqYXJtLCBoeWJyaWQsIG5vblJlcHVkaWF0aW9uLCB0aW1lb3V0LCBkZWNyeXB0LCBpbXBsaWNpdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgaWYgKG9wdGlvbnM/LmZsYWcgPT09IHJldHJ5KSB7XG4gICAgICAgIGF1dGhSZXNwb25zZSA9IG9wdGlvbnMuYXV0aFJlc3BvbnNlO1xuICAgICAgICByZWRpcmVjdFVyaSA9IG9wdGlvbnMucmVkaXJlY3RVcmk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShjdXJyZW50VXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGN1cnJlbnRVcmw7XG4gICAgICAgICAgICBjdXJyZW50VXJsID0gbmV3IFVSTChjdXJyZW50VXJsLnVybCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUE9TVCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgb2F1dGguZm9ybVBvc3RSZXNwb25zZShyZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeWJyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVcmwuaGFzaCA9IHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgcGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcigndW5leHBlY3RlZCBSZXF1ZXN0IEhUVFAgbWV0aG9kJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWRpcmVjdFVyaSA9IHN0cmlwUGFyYW1zKGN1cnJlbnRVcmwpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgISFqYXJtOlxuICAgICAgICAgICAgICAgIGF1dGhSZXNwb25zZSA9IGF3YWl0IGphcm0oY3VycmVudFVybCwgY2hlY2tzPy5leHBlY3RlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgISFoeWJyaWQ6XG4gICAgICAgICAgICAgICAgYXV0aFJlc3BvbnNlID0gYXdhaXQgaHlicmlkKGN1cnJlbnRVcmwsIGNoZWNrcz8uZXhwZWN0ZWROb25jZSwgY2hlY2tzPy5leHBlY3RlZFN0YXRlLCBjaGVja3M/Lm1heEFnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEhaW1wbGljaXQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0aG9yaXphdGlvbkNvZGVHcmFudCgpIGNhbm5vdCBiZSB1c2VkIGJ5IHJlc3BvbnNlX3R5cGU9aWRfdG9rZW4gY2xpZW50cycpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhdXRoUmVzcG9uc2UgPSBvYXV0aC52YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgYywgY3VycmVudFVybC5zZWFyY2hQYXJhbXMsIGNoZWNrcz8uZXhwZWN0ZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCBhdXRoUmVzcG9uc2UsIHJlZGlyZWN0VXJpLCBjaGVja3M/LnBrY2VDb2RlVmVyaWZpZXIgfHwgb2F1dGgubm9wa2NlLCB7XG4gICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzOiB0b2tlbkVuZHBvaW50UGFyYW1ldGVycyxcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGlmICh0eXBlb2YgY2hlY2tzPy5leHBlY3RlZE5vbmNlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgY2hlY2tzPy5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNoZWNrcy5pZFRva2VuRXhwZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlUmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlLCB7XG4gICAgICAgIGV4cGVjdGVkTm9uY2U6IGNoZWNrcz8uZXhwZWN0ZWROb25jZSxcbiAgICAgICAgbWF4QWdlOiBjaGVja3M/Lm1heEFnZSxcbiAgICAgICAgcmVxdWlyZUlkVG9rZW46IGNoZWNrcz8uaWRUb2tlbkV4cGVjdGVkLFxuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25Db2RlR3JhbnQoY29uZmlnLCB1bmRlZmluZWQsIGNoZWNrcywgdG9rZW5FbmRwb2ludFBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGZsYWc6IHJldHJ5LFxuICAgICAgICAgICAgICAgIGF1dGhSZXNwb25zZTogYXV0aFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiByZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXN1bHQuaWRfdG9rZW4gJiYgKGF3YWl0IG5vblJlcHVkaWF0aW9uPy4ocmVzcG9uc2UpKTtcbiAgICBhZGRIZWxwZXJzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSkFSTVJlc3BvbnNlKGNvbmZpZywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZFN0YXRlKSB7XG4gICAgY29uc3QgeyBhcywgYywgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQsIGRlY3J5cHQsIGp3a3NDYWNoZSB9ID0gaW50KGNvbmZpZyk7XG4gICAgcmV0dXJuIG9hdXRoXG4gICAgICAgIC52YWxpZGF0ZUp3dEF1dGhSZXNwb25zZShhcywgYywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZFN0YXRlLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgICAgICBbb2F1dGguandrc0NhY2hlXTogandrc0NhY2hlLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDb2RlSWRUb2tlblJlc3BvbnNlKGNvbmZpZywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIGZhcGkpIHtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTm9uY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImV4cGVjdGVkTm9uY2VcIiBtdXN0IGJlIGEgc3RyaW5nJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0ZWRTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBleHBlY3RlZFN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJleHBlY3RlZFN0YXRlXCIgbXVzdCBiZSBhIHN0cmluZycsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgY29uc3QgeyBhcywgYywgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQsIGRlY3J5cHQsIGp3a3NDYWNoZSB9ID0gaW50KGNvbmZpZyk7XG4gICAgcmV0dXJuIChmYXBpXG4gICAgICAgID8gb2F1dGgudmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlXG4gICAgICAgIDogb2F1dGgudmFsaWRhdGVDb2RlSWRUb2tlblJlc3BvbnNlKShhcywgYywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgICAgIFtvYXV0aC5qd2tzQ2FjaGVdOiBqd2tzQ2FjaGUsXG4gICAgfSkuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW5HcmFudChjb25maWcsIHJlZnJlc2hUb2tlbiwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIG5vblJlcHVkaWF0aW9uLCB0aW1lb3V0LCBkZWNyeXB0IH0gPSBpbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoXG4gICAgICAgIC5yZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QoYXMsIGMsIGF1dGgsIHJlZnJlc2hUb2tlbiwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGNvbnN0IHAgPSBvYXV0aC5wcm9jZXNzUmVmcmVzaFRva2VuUmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlLCB7XG4gICAgICAgIFtvYXV0aC5qd2VEZWNyeXB0XTogZGVjcnlwdCxcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHA7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldHJ5YWJsZShlcnIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmcmVzaFRva2VuR3JhbnQoY29uZmlnLCByZWZyZXNoVG9rZW4sIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGZsYWc6IHJldHJ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIHJlc3VsdC5pZF90b2tlbiAmJiAoYXdhaXQgbm9uUmVwdWRpYXRpb24/LihyZXNwb25zZSkpO1xuICAgIGFkZEhlbHBlcnMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsaWVudENyZWRlbnRpYWxzR3JhbnQoY29uZmlnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aFxuICAgICAgICAuY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QoYXMsIGMsIGF1dGgsIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGNvbnN0IHAgPSBvYXV0aC5wcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgYywgcmVzcG9uc2UpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRDcmVkZW50aWFsc0dyYW50KGNvbmZpZywgcGFyYW1ldGVycywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmxhZzogcmV0cnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgYWRkSGVscGVycyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBdXRob3JpemF0aW9uVXJsKGNvbmZpZywgcGFyYW1ldGVycykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgeyBhcywgYywgdGxzT25seSwgaHlicmlkLCBqYXJtLCBpbXBsaWNpdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbkVuZHBvaW50ID0gb2F1dGgucmVzb2x2ZUVuZHBvaW50KGFzLCAnYXV0aG9yaXphdGlvbl9lbmRwb2ludCcsIGZhbHNlLCB0bHNPbmx5KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKCdjbGllbnRfaWQnKSkge1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnY2xpZW50X2lkJywgYy5jbGllbnRfaWQpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKCdyZXF1ZXN0X3VyaScpICYmICFwYXJhbWV0ZXJzLmhhcygncmVxdWVzdCcpKSB7XG4gICAgICAgIGlmICghcGFyYW1ldGVycy5oYXMoJ3Jlc3BvbnNlX3R5cGUnKSkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5zZXQoJ3Jlc3BvbnNlX3R5cGUnLCBoeWJyaWQgPyAnY29kZSBpZF90b2tlbicgOiBpbXBsaWNpdCA/ICdpZF90b2tlbicgOiAnY29kZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsaWNpdCAmJiAhcGFyYW1ldGVycy5oYXMoJ25vbmNlJykpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdyZXNwb25zZV90eXBlPWlkX3Rva2VuIGNsaWVudHMgbXVzdCBwcm92aWRlIGEgbm9uY2UgcGFyYW1ldGVyIGluIHRoZWlyIGF1dGhvcml6YXRpb24gcmVxdWVzdCBwYXJhbWV0ZXJzJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoamFybSkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5zZXQoJ3Jlc3BvbnNlX21vZGUnLCAnand0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgcGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvbkVuZHBvaW50LnNlYXJjaFBhcmFtcy5hcHBlbmQoaywgdik7XG4gICAgfVxuICAgIHJldHVybiBhdXRob3JpemF0aW9uRW5kcG9pbnQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRBdXRob3JpemF0aW9uVXJsV2l0aEpBUihjb25maWcsIHBhcmFtZXRlcnMsIHNpZ25pbmdLZXksIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb25FbmRwb2ludCA9IGJ1aWxkQXV0aG9yaXphdGlvblVybChjb25maWcsIHBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMgPSBhdXRob3JpemF0aW9uRW5kcG9pbnQuc2VhcmNoUGFyYW1zO1xuICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJzaWduaW5nS2V5XCIgbXVzdCBiZSBwcm92aWRlZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYXMsIGMgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBvYXV0aFxuICAgICAgICAuaXNzdWVSZXF1ZXN0T2JqZWN0KGFzLCBjLCBwYXJhbWV0ZXJzLCBzaWduaW5nS2V5LCBvcHRpb25zKVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICByZXR1cm4gYnVpbGRBdXRob3JpemF0aW9uVXJsKGNvbmZpZywgeyByZXF1ZXN0IH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkQXV0aG9yaXphdGlvblVybFdpdGhQQVIoY29uZmlnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uRW5kcG9pbnQgPSBidWlsZEF1dGhvcml6YXRpb25VcmwoY29uZmlnLCBwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aFxuICAgICAgICAucHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGMsIGF1dGgsIGF1dGhvcml6YXRpb25FbmRwb2ludC5zZWFyY2hQYXJhbXMsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGNvbnN0IHAgPSBvYXV0aC5wcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQXV0aG9yaXphdGlvblVybFdpdGhQQVIoY29uZmlnLCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRBdXRob3JpemF0aW9uVXJsKGNvbmZpZywgeyByZXF1ZXN0X3VyaTogcmVzdWx0LnJlcXVlc3RfdXJpIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRW5kU2Vzc2lvblVybChjb25maWcsIHBhcmFtZXRlcnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIHRsc09ubHkgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IGVuZFNlc3Npb25FbmRwb2ludCA9IG9hdXRoLnJlc29sdmVFbmRwb2ludChhcywgJ2VuZF9zZXNzaW9uX2VuZHBvaW50JywgZmFsc2UsIHRsc09ubHkpO1xuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGlmICghcGFyYW1ldGVycy5oYXMoJ2NsaWVudF9pZCcpKSB7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KCdjbGllbnRfaWQnLCBjLmNsaWVudF9pZCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgIGVuZFNlc3Npb25FbmRwb2ludC5zZWFyY2hQYXJhbXMuYXBwZW5kKGssIHYpO1xuICAgIH1cbiAgICByZXR1cm4gZW5kU2Vzc2lvbkVuZHBvaW50O1xufVxuZnVuY3Rpb24gY2hlY2tDb25maWcoaW5wdXQpIHtcbiAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIENvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImNvbmZpZ1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQ29uZmlndXJhdGlvbicsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCkgIT09IENvbmZpZ3VyYXRpb24ucHJvdG90eXBlKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdzdWJjbGFzc2luZyBDb25maWd1cmF0aW9uIGlzIG5vdCBhbGxvd2VkJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaWduYWwodGltZW91dCkge1xuICAgIHJldHVybiB0aW1lb3V0ID8gQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0ICogMTAwMCkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVc2VySW5mbyhjb25maWcsIGFjY2Vzc1Rva2VuLCBleHBlY3RlZFN1YmplY3QsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGZldGNoLCB0bHNPbmx5LCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aFxuICAgICAgICAudXNlckluZm9SZXF1ZXN0KGFzLCBjLCBhY2Nlc3NUb2tlbiwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBEUG9QOiBvcHRpb25zPy5EUG9QLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgbGV0IGV4ZWMgPSBvYXV0aC5wcm9jZXNzVXNlckluZm9SZXNwb25zZShhcywgYywgZXhwZWN0ZWRTdWJqZWN0LCByZXNwb25zZSwge1xuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBleGVjO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoVXNlckluZm8oY29uZmlnLCBhY2Nlc3NUb2tlbiwgZXhwZWN0ZWRTdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICBvYXV0aC5nZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi9qd3QnICYmXG4gICAgICAgIChhd2FpdCBub25SZXB1ZGlhdGlvbj8uKHJlc3BvbnNlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJldHJ5YWJsZShlcnIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCAmJiBvcHRpb25zLmZsYWcgIT09IHJldHJ5KSB7XG4gICAgICAgIHJldHVybiBvYXV0aC5pc0RQb1BOb25jZUVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b2tlbkludHJvc3BlY3Rpb24oY29uZmlnLCB0b2tlbiwgcGFyYW1ldGVycykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIG5vblJlcHVkaWF0aW9uLCB0aW1lb3V0LCBkZWNyeXB0IH0gPSBpbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoXG4gICAgICAgIC5pbnRyb3NwZWN0aW9uUmVxdWVzdChhcywgYywgYXV0aCwgdG9rZW4sIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvYXV0aFxuICAgICAgICAucHJvY2Vzc0ludHJvc3BlY3Rpb25SZXNwb25zZShhcywgYywgcmVzcG9uc2UsIHtcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIG9hdXRoLmdldENvbnRlbnRUeXBlKHJlc3BvbnNlKSA9PT0gJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0JyAmJlxuICAgICAgICAoYXdhaXQgbm9uUmVwdWRpYXRpb24/LihyZXNwb25zZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCByZXRyeSA9IFN5bWJvbCgpO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyaWNHcmFudFJlcXVlc3QoY29uZmlnLCBncmFudFR5cGUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0LCBkZWNyeXB0IH0gPSBpbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvYXV0aFxuICAgICAgICAuZ2VuZXJpY1Rva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCBncmFudFR5cGUsIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyksIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBsZXQgcmVjb2duaXplZFRva2VuVHlwZXM7XG4gICAgICAgIGlmIChncmFudFR5cGUgPT09ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTp0b2tlbi1leGNoYW5nZScpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZWRUb2tlblR5cGVzID0geyBuX2E6ICgpID0+IHsgfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYXV0aC5wcm9jZXNzR2VuZXJpY1Rva2VuRW5kcG9pbnRSZXNwb25zZShhcywgYywgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgIFtvYXV0aC5qd2VEZWNyeXB0XTogZGVjcnlwdCxcbiAgICAgICAgICAgIHJlY29nbml6ZWRUb2tlblR5cGVzLFxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBhZGRIZWxwZXJzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b2tlblJldm9jYXRpb24oY29uZmlnLCB0b2tlbiwgcGFyYW1ldGVycykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQgfSA9IGludChjb25maWcpO1xuICAgIHJldHVybiBvYXV0aFxuICAgICAgICAucmV2b2NhdGlvblJlcXVlc3QoYXMsIGMsIGF1dGgsIHRva2VuLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzOiBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLnRoZW4ob2F1dGgucHJvY2Vzc1Jldm9jYXRpb25SZXNwb25zZSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcm90ZWN0ZWRSZXNvdXJjZShjb25maWcsIGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgaGVhZGVycyB8fD0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAoIWhlYWRlcnMuaGFzKCd1c2VyLWFnZW50JykpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ3VzZXItYWdlbnQnLCBVU0VSX0FHRU5UKTtcbiAgICB9XG4gICAgY29uc3QgeyBmZXRjaCwgdGxzT25seSwgdGltZW91dCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgZXhlYyA9IG9hdXRoLnByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGJvZHksIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBleGVjO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoUHJvdGVjdGVkUmVzb3VyY2UoY29uZmlnLCBhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIGJvZHksIGhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGZsYWc6IHJldHJ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openid-client/build/index.js\n");

/***/ })

};
;